"use strict";(self.webpackChunkseata_website=self.webpackChunkseata_website||[]).push([[26124],{2611:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>i,toc:()=>l});var s=t(74848),r=t(28453);const a={title:"Getting Started with Seata Network Communication Source Code",keywords:["Seata","RPC","Source Code","Distributed Transactions"],description:"A comprehensive introductory analysis of Seata's RPC source code",author:"Jin He",date:new Date("2024-12-18T00:00:00.000Z")},o=void 0,i={permalink:"/blog/seata-rpc-analysis",editUrl:"https://github.com/apache/incubator-seata-website/blob/docusaurus/i18n/en/docusaurus-plugin-content-blog/seata-rpc-analysis.md",source:"@site/i18n/en/docusaurus-plugin-content-blog/seata-rpc-analysis.md",title:"Getting Started with Seata Network Communication Source Code",description:"A comprehensive introductory analysis of Seata's RPC source code",date:"2024-12-18T00:00:00.000Z",formattedDate:"December 18, 2024",tags:[],readingTime:44.2,hasTruncateMarker:!1,authors:[{name:"Jin He"}],frontMatter:{title:"Getting Started with Seata Network Communication Source Code",keywords:["Seata","RPC","Source Code","Distributed Transactions"],description:"A comprehensive introductory analysis of Seata's RPC source code",author:"Jin He",date:"2024-12-18T00:00:00.000Z"},unlisted:!1,prevItem:{title:"seata-namingserver",permalink:"/blog/seata-namingserver"},nextItem:{title:"Go Language Client Communication with Seata Server",permalink:"/blog/seata-grpc-client"}},c={authorsImageUrls:[void 0]},l=[{value:"Overall Class Hierarchy Structure",id:"overall-class-hierarchy-structure",level:2},{value:"How to Start the Server and Client",id:"how-to-start-the-server-and-client",level:2},{value:"How the Server Starts",id:"how-the-server-starts",level:3},{value:"Registering Processors",id:"registering-processors",level:4},{value:"Initializing the Scheduled Thread Pool",id:"initializing-the-scheduled-thread-pool",level:4},{value:"Starting the ServerBootstrap",id:"starting-the-serverbootstrap",level:4},{value:"How the Client Starts",id:"how-the-client-starts",level:3},{value:"Initialization of TM",id:"initialization-of-tm",level:4},{value:"Initialization of RM",id:"initialization-of-rm",level:4},{value:"How Messages Are Sent and Handled",id:"how-messages-are-sent-and-handled",level:2},{value:"Synchronous and Asynchronous",id:"synchronous-and-asynchronous",level:3},{value:"Asynchronous Invocation",id:"asynchronous-invocation",level:3},{value:"Synchronous Invocation",id:"synchronous-invocation",level:3},{value:"Message Handling",id:"message-handling",level:3},{value:"Batch Sending",id:"batch-sending",level:3},{value:"How Seata Manages Channel",id:"how-seata-manages-channel",level:2},{value:"Client Channel",id:"client-channel",level:3},{value:"Core Classes of the Object Pool",id:"core-classes-of-the-object-pool",level:4},{value:"How to Pool Channel",id:"how-to-pool-channel",level:4},{value:"Acquiring Channel",id:"acquiring-channel",level:4},{value:"Server Channel",id:"server-channel",level:3},{value:"Handling Client Registration",id:"handling-client-registration",level:4},{value:"Acquiring Channel",id:"acquiring-channel-1",level:4},{value:"Summary in a Sequence Diagram",id:"summary-in-a-sequence-diagram",level:3},{value:"How Seata Designs Its Protocol",id:"how-seata-designs-its-protocol",level:2},{value:"V1 Version Protocol",id:"v1-version-protocol",level:3},{value:"How Encoding and Decoding Are Performed",id:"how-encoding-and-decoding-are-performed",level:3},{value:"Summary",id:"summary",level:2}];function d(e){const n={a:"a",blockquote:"blockquote",code:"code",h2:"h2",h3:"h3",h4:"h4",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:"In the previous articles, we have thoroughly discussed Seata's XA, AT, and TCC modes, all of which are different transaction models defined within the global framework of Seata."}),"\n",(0,s.jsx)(n.p,{children:"We know that in Seata, there are three types of roles: TC (Transaction Coordinator), RM (Resource Manager), and TM (Transaction Manager). The Seata Server acts as a TC to coordinate the commit and rollback of branch transactions, while various resources act as RMs and TMs. So, how do these three communicate with each other?"}),"\n",(0,s.jsx)(n.p,{children:"Therefore, this article will explore how Seata performs network communication at the underlying level."}),"\n",(0,s.jsx)(n.h2,{id:"overall-class-hierarchy-structure",children:"Overall Class Hierarchy Structure"}),"\n",(0,s.jsx)(n.p,{children:"Let's start by looking at the big picture, examining the overall RPC class hierarchy structure of Seata."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"image-20241217222005964",src:t(98021).A+"",width:"1948",height:"1016"})}),"\n",(0,s.jsx)(n.p,{children:"From the class hierarchy structure, it can be seen that AbstractNettyRemoting is the top-level abstract class for the entire Seata network communication."}),"\n",(0,s.jsx)(n.p,{children:"In this class, some basic common methods of RPC are mainly implemented, such as synchronous call sendSync, asynchronous call sendAsync, etc."}),"\n",(0,s.jsx)(n.p,{children:"Indeed, when it comes to network calls, they essentially boil down to synchronous calls and asynchronous calls; other aspects like requests and responses are just distinctions in message content."}),"\n",(0,s.jsx)(n.p,{children:"So, in Seata, I personally think there should also be a top-level interface Remoting, similar to the following:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"import io.netty.channel.Channel;\nimport java.util.concurrent.TimeoutException;\n\npublic interface Remoting<Req, Resp> {\n\n    /**\n     * Synchronous call\n     */ \n    Resp sendSync(Channel channel, Req request, long timeout) throws TimeoutException;\n\n    /** \n     * Asynchronous call\n     */ \n    void sendAsync(Channel channel, Req request);\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"While AbstractNettyRemoting implements general network calling methods, there are still some differences among different roles. For example, for the server, its request call needs to know which client to send to, whereas for the TM and RM, they can simply send requests without specifying a particular TC service. They only need to find an appropriate server node via a load balancing algorithm in the implementation class."}),"\n",(0,s.jsx)(n.p,{children:"Thus, RemotingServer and RemotingClient are differentiated, but they still rely on AbstractNettyRemoting for network calls at the bottom layer, so each has subclasses that implement AbstractNettyRemoting."}),"\n",(0,s.jsx)(n.p,{children:"One might say that this design in Seata is quite commendable, serving as a general solution pattern for remote communications in this kind of Client-Server architecture."}),"\n",(0,s.jsx)(n.h2,{id:"how-to-start-the-server-and-client",children:"How to Start the Server and Client"}),"\n",(0,s.jsx)(n.p,{children:"After discussing the underlying class hierarchy of Seata, let's look from the perspectives of the Server and Client on how they start up and what needs to be done during startup."}),"\n",(0,s.jsx)(n.h3,{id:"how-the-server-starts",children:"How the Server Starts"}),"\n",(0,s.jsx)(n.p,{children:"As an independent Spring Boot project, how does the Seata Server automatically perform certain tasks when Spring Boot starts?"}),"\n",(0,s.jsxs)(n.p,{children:["Seata achieves this by implementing the ",(0,s.jsx)(n.code,{children:"CommandLineRunner"})," interface. The principle behind this is not within the scope of this article."]}),"\n",(0,s.jsxs)(n.p,{children:["We mainly focus on its ",(0,s.jsx)(n.code,{children:"run"})," method:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'// org.apache.seata.server.ServerRunner#run\npublic void run(String... args) {\n    try {\n        long start = System.currentTimeMillis();\n        seataServer.start(args);\n        started = true;\n        long cost = System.currentTimeMillis() - start;\n        LOGGER.info("\\r\\n you can visit seata console UI on http://127.0.0.1:{}. \\r\\n log path: {}.", this.port, this.logPath);\n        LOGGER.info("seata server started in {} millSeconds", cost);\n    } catch (Throwable e) {\n        started = Boolean.FALSE;\n        LOGGER.error("seata server start error: {} ", e.getMessage(), e);\n        System.exit(-1);\n    }\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["The core logic lies within the ",(0,s.jsx)(n.code,{children:"seataServer.start()"})," method:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'// org.apache.seata.server.Server#start\npublic void start(String[] args) {\n    // Parameter parser used to parse startup parameters from the shell script\n    ParameterParser parameterParser = new ParameterParser(args);\n    // Initialize metrics\n    MetricsManager.get().init();\n    ThreadPoolExecutor workingThreads = new ThreadPoolExecutor(\n            NettyServerConfig.getMinServerPoolSize(),\n            NettyServerConfig.getMaxServerPoolSize(),\n            NettyServerConfig.getKeepAliveTime(), TimeUnit.SECONDS,\n            new LinkedBlockingQueue<>(NettyServerConfig.getMaxTaskQueueSize()),\n            new NamedThreadFactory("ServerHandlerThread", NettyServerConfig.getMaxServerPoolSize()),\n            new ThreadPoolExecutor.CallerRunsPolicy());\n    // 127.0.0.1 and 0.0.0.0 are not valid here.\n    if (NetUtil.isValidIp(parameterParser.getHost(), false)) {\n        XID.setIpAddress(parameterParser.getHost());\n    } else {\n        String preferredNetworks = ConfigurationFactory.getInstance().getConfig(REGISTRY_PREFERED_NETWORKS);\n        if (StringUtils.isNotBlank(preferredNetworks)) {\n            XID.setIpAddress(NetUtil.getLocalIp(preferredNetworks.split(REGEX_SPLIT_CHAR)));\n        } else {\n            XID.setIpAddress(NetUtil.getLocalIp());\n        }\n    }\n\n    /**\n     * Main tasks performed:\n     * 1. Set workingThreads as the messageExecutor handler for AbstractNettyRemoting\n     * 2. Create ServerBootstrap, configure Boss and Worker, and set the port that the Seata Server listens on\n     * 3. Set outbound and inbound handlers ServerHandler, which is a composite handler of ChannelDuplexHandler\n     */\n    NettyRemotingServer nettyRemotingServer = new NettyRemotingServer(workingThreads);\n    XID.setPort(nettyRemotingServer.getListenPort());\n    UUIDGenerator.init(parameterParser.getServerNode());\n    ConfigurableListableBeanFactory beanFactory = ((GenericWebApplicationContext) ObjectHolder.INSTANCE.getObject(OBJECT_KEY_SPRING_APPLICATION_CONTEXT)).getBeanFactory();\n    DefaultCoordinator coordinator = DefaultCoordinator.getInstance(nettyRemotingServer);\n    if (coordinator instanceof ApplicationListener) {\n        beanFactory.registerSingleton(NettyRemotingServer.class.getName(), nettyRemotingServer);\n        beanFactory.registerSingleton(DefaultCoordinator.class.getName(), coordinator);\n        ((GenericWebApplicationContext) ObjectHolder.INSTANCE.getObject(OBJECT_KEY_SPRING_APPLICATION_CONTEXT)).addApplicationListener((ApplicationListener<?>) coordinator);\n    }\n    // Log store mode: file, db, redis\n    SessionHolder.init();\n    LockerManagerFactory.init();\n    // Initialize a series of scheduled thread pools for retrying transaction commit/rollback, etc.\n    coordinator.init();\n    // Set the transaction processing Handler to DefaultCoordinator\n    nettyRemotingServer.setHandler(coordinator);\n    serverInstance.serverInstanceInit();\n    // Let ServerRunner handle destruction instead of ShutdownHook, see https://github.com/seata/seata/issues/4028\n    ServerRunner.addDisposable(coordinator);\n    // Server initialization\n    nettyRemotingServer.init();\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["The final ",(0,s.jsx)(n.code,{children:"nettyRemotingServer.init()"})," is crucial for starting the entire Seata Server, primarily performing the following tasks:"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Register a series of handlers"}),"\n",(0,s.jsx)(n.li,{children:"Initialize a scheduled thread pool for cleaning up expired MessageFuture objects"}),"\n",(0,s.jsx)(n.li,{children:"Start the ServerBootstrap and register the TC service with the registry center, such as Nacos"}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"registering-processors",children:"Registering Processors"}),"\n",(0,s.jsxs)(n.p,{children:["Within Seata, a ",(0,s.jsx)(n.code,{children:"Pair"})," object is used to associate a processor with an executor (thread pool), as shown below:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"package org.apache.seata.core.rpc.processor;\n\npublic final class Pair<T1, T2> {\n\n    private final T1 first;\n    private final T2 second;\n\n    public Pair(T1 first, T2 second) {\n        this.first = first;\n        this.second = second;\n    }\n\n    public T1 getFirst() {\n        return first;\n    }\n\n    public T2 getSecond() {\n        return second;\n    }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"Registering processors essentially involves associating message types, the processors that handle those messages, and the specific thread pools for execution, all stored in a hash table."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"// AbstractNettyRemotingServer\nprotected final Map<Integer/*MessageType*/, Pair<RemotingProcessor, ExecutorService>> processorTable = new HashMap<>(32);\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"// org.apache.seata.core.rpc.netty.NettyRemotingServer#registerProcessor\nprivate void registerProcessor() {\n    // 1. Register request message processors\n    ServerOnRequestProcessor onRequestProcessor = new ServerOnRequestProcessor(this, getHandler());\n    ShutdownHook.getInstance().addDisposable(onRequestProcessor);\n    super.registerProcessor(MessageType.TYPE_BRANCH_REGISTER, onRequestProcessor, messageExecutor);\n    super.registerProcessor(MessageType.TYPE_BRANCH_STATUS_REPORT, onRequestProcessor, messageExecutor);\n    super.registerProcessor(MessageType.TYPE_GLOBAL_BEGIN, onRequestProcessor, messageExecutor);\n    super.registerProcessor(MessageType.TYPE_GLOBAL_COMMIT, onRequestProcessor, messageExecutor);\n    super.registerProcessor(MessageType.TYPE_GLOBAL_LOCK_QUERY, onRequestProcessor, messageExecutor);\n    super.registerProcessor(MessageType.TYPE_GLOBAL_REPORT, onRequestProcessor, messageExecutor);\n    super.registerProcessor(MessageType.TYPE_GLOBAL_ROLLBACK, onRequestProcessor, messageExecutor);\n    super.registerProcessor(MessageType.TYPE_GLOBAL_STATUS, onRequestProcessor, messageExecutor);\n    super.registerProcessor(MessageType.TYPE_SEATA_MERGE, onRequestProcessor, messageExecutor);\n    // 2. Register response message processors\n    ServerOnResponseProcessor onResponseProcessor = new ServerOnResponseProcessor(getHandler(), getFutures());\n    super.registerProcessor(MessageType.TYPE_BRANCH_COMMIT_RESULT, onResponseProcessor, branchResultMessageExecutor);\n    super.registerProcessor(MessageType.TYPE_BRANCH_ROLLBACK_RESULT, onResponseProcessor, branchResultMessageExecutor);\n    // 3. Register RM message processors\n    RegRmProcessor regRmProcessor = new RegRmProcessor(this);\n    super.registerProcessor(MessageType.TYPE_REG_RM, regRmProcessor, messageExecutor);\n    // 4. Register TM message processors\n    RegTmProcessor regTmProcessor = new RegTmProcessor(this);\n    super.registerProcessor(MessageType.TYPE_REG_CLT, regTmProcessor, null);\n    // 5. Register heartbeat message processors\n    ServerHeartbeatProcessor heartbeatMessageProcessor = new ServerHeartbeatProcessor(this);\n    super.registerProcessor(MessageType.TYPE_HEARTBEAT_MSG, heartbeatMessageProcessor, null);\n}\n\n// org.apache.seata.core.rpc.netty.AbstractNettyRemotingServer#registerProcessor\npublic void registerProcessor(int messageType, RemotingProcessor processor, ExecutorService executor) {\n    Pair<RemotingProcessor, ExecutorService> pair = new Pair<>(processor, executor);\n    this.processorTable.put(messageType, pair);\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["You might notice that during the registration of some processors, the passed-in thread pool is ",(0,s.jsx)(n.code,{children:"null"}),". In such cases, which thread will execute the corresponding message?"]}),"\n",(0,s.jsx)(n.p,{children:"We will discuss this in a later section."}),"\n",(0,s.jsx)(n.h4,{id:"initializing-the-scheduled-thread-pool",children:"Initializing the Scheduled Thread Pool"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'// org.apache.seata.core.rpc.netty.AbstractNettyRemoting#init\npublic void init() {\n    timerExecutor.scheduleAtFixedRate(() -> {\n        for (Map.Entry<Integer, MessageFuture> entry : futures.entrySet()) {\n            MessageFuture future = entry.getValue();\n            if (future.isTimeout()) {\n                futures.remove(entry.getKey());\n                RpcMessage rpcMessage = future.getRequestMessage();\n                future.setResultMessage(new TimeoutException(String.format("msgId: %s, msgType: %s, msg: %s, request timeout",\n                        rpcMessage.getId(), String.valueOf(rpcMessage.getMessageType()), rpcMessage.getBody().toString())));\n                if (LOGGER.isDebugEnabled()) {\n                    LOGGER.debug("timeout clear future: {}", entry.getValue().getRequestMessage().getBody());\n                }\n            }\n        }\n        nowMills = System.currentTimeMillis();\n    }, TIMEOUT_CHECK_INTERVAL, TIMEOUT_CHECK_INTERVAL, TimeUnit.MILLISECONDS);\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["There's not much to explain here\u2014it initializes a scheduled thread pool that periodically cleans up timed-out ",(0,s.jsx)(n.code,{children:"MessageFuture"})," objects. The ",(0,s.jsx)(n.code,{children:"MessageFuture"})," is key to Seata converting asynchronous calls into synchronous ones, which we will discuss in detail later."]}),"\n",(0,s.jsx)(n.h4,{id:"starting-the-serverbootstrap",children:"Starting the ServerBootstrap"}),"\n",(0,s.jsxs)(n.p,{children:["Finally, starting the ",(0,s.jsx)(n.code,{children:"ServerBootstrap"})," is mostly related to Netty."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'// org.apache.seata.core.rpc.netty.NettyServerBootstrap#start\npublic void start() {\n    int port = getListenPort();\n    this.serverBootstrap.group(this.eventLoopGroupBoss, this.eventLoopGroupWorker)\n            .channel(NettyServerConfig.SERVER_CHANNEL_CLAZZ)\n            .option(ChannelOption.SO_BACKLOG, nettyServerConfig.getSoBackLogSize())\n            .option(ChannelOption.SO_REUSEADDR, true)\n            .childOption(ChannelOption.SO_KEEPALIVE, true)\n            .childOption(ChannelOption.TCP_NODELAY, true)\n            .childOption(ChannelOption.SO_SNDBUF, nettyServerConfig.getServerSocketSendBufSize())\n            .childOption(ChannelOption.SO_RCVBUF, nettyServerConfig.getServerSocketResvBufSize())\n            .childOption(ChannelOption.WRITE_BUFFER_WATER_MARK, new WriteBufferWaterMark(nettyServerConfig.getWriteBufferLowWaterMark(), nettyServerConfig.getWriteBufferHighWaterMark()))\n            .localAddress(new InetSocketAddress(port))\n            .childHandler(new ChannelInitializer<SocketChannel>() {\n                @Override\n                public void initChannel(SocketChannel ch) {\n                    // Multi-version protocol decoder\n                    MultiProtocolDecoder multiProtocolDecoder = new MultiProtocolDecoder(channelHandlers);\n                    ch.pipeline()\n                            .addLast(new IdleStateHandler(nettyServerConfig.getChannelMaxReadIdleSeconds(), 0, 0))\n                            .addLast(multiProtocolDecoder);\n                }\n            });\n    try {\n        this.serverBootstrap.bind(port).sync();\n        LOGGER.info("Server started, service listen port: {}", getListenPort());\n        InetSocketAddress address = new InetSocketAddress(XID.getIpAddress(), XID.getPort());\n        for (RegistryService<?> registryService : MultiRegistryFactory.getInstances()) {\n            // Register service\n            registryService.register(address);\n        }\n        initialized.set(true);\n    } catch (SocketException se) {\n        throw new RuntimeException("Server start failed, the listen port: " + getListenPort(), se);\n    } catch (Exception exx) {\n        throw new RuntimeException("Server start failed", exx);\n    }\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"childOption"})," settings during the startup of ",(0,s.jsx)(n.code,{children:"ServerBootstrap"})," belong to the networking part and won't be explained in depth here."]}),"\n",(0,s.jsxs)(n.p,{children:["You might have a question regarding why only a ",(0,s.jsx)(n.code,{children:"MultiProtocolDecoder"})," is added to the pipeline, what about the business handler?"]}),"\n",(0,s.jsxs)(n.p,{children:["In fact, the ",(0,s.jsx)(n.code,{children:"channelHandlers"})," passed into the constructor of ",(0,s.jsx)(n.code,{children:"MultiProtocolDecoder"})," include the ",(0,s.jsx)(n.code,{children:"ServerHandler"}),", which is set when creating the ",(0,s.jsx)(n.code,{children:"NettyRemotingServer"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"This approach is related to Seata's multi-version protocol support."}),"\n",(0,s.jsxs)(n.p,{children:["When the Seata Server decodes messages for the first time after starting, it removes the ",(0,s.jsx)(n.code,{children:"MultiProtocolDecoder"})," from the pipeline and adds specific ",(0,s.jsx)(n.code,{children:"Encoder"})," and ",(0,s.jsx)(n.code,{children:"Decoder"})," based on the version to the pipeline. At this point, the ",(0,s.jsx)(n.code,{children:"ServerHandler"})," is also added to the pipeline."]}),"\n",(0,s.jsx)(n.h3,{id:"how-the-client-starts",children:"How the Client Starts"}),"\n",(0,s.jsxs)(n.p,{children:["For the Client, since we typically use Seata within a Spring Boot application, our focus lies within the ",(0,s.jsx)(n.code,{children:"SeataAutoConfiguration"})," class."]}),"\n",(0,s.jsxs)(n.p,{children:["In this class, a ",(0,s.jsx)(n.code,{children:"GlobalTransactionScanner"})," object is created. Notably, it implements ",(0,s.jsx)(n.code,{children:"InitializingBean"}),", so we turn our attention to the ",(0,s.jsx)(n.code,{children:"afterPropertiesSet"})," method."]}),"\n",(0,s.jsx)(n.p,{children:"Indeed, within this method, the initialization of TM (Transaction Manager) and RM (Resource Manager) takes place."}),"\n",(0,s.jsx)(n.h4,{id:"initialization-of-tm",children:"Initialization of TM"}),"\n",(0,s.jsx)(n.p,{children:"For TM, the initialization logic is as follows:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"public static void init(String applicationId, String transactionServiceGroup, String accessKey, String secretKey) {\n    /**\n     * Main tasks include:\n     * 1. Creating a thread pool as the messageExecutor for AbstractNettyRemotingClient\n     * 2. Setting the transaction role transactionRole to TM_ROLE\n     * 3. Creating Bootstrap and setting outbound and inbound handlers ClientHandler\n     * 4. Creating a client Channel manager NettyClientChannelManager\n     */\n    TmNettyRemotingClient tmNettyRemotingClient = TmNettyRemotingClient.getInstance(applicationId, transactionServiceGroup, accessKey, secretKey);\n\n    /**\n     * Main tasks include:\n     * 1. Registering a series of processors\n     * 2. Creating a scheduled thread pool that periodically initiates connections to servers within the transaction group; if the connection is broken, it tries to reconnect\n     * 3. If the client allows batch message sending, creating a mergeSendExecutorService thread pool and submitting MergedSendRunnable tasks\n     * 4. Initializing a scheduled thread pool to clean up expired MessageFuture objects\n     * 5. Starting the client Bootstrap\n     * 6. Initializing connections initConnection\n     */\n    tmNettyRemotingClient.init();\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"The logic for starting the client Bootstrap is as follows:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'@Override\npublic void start() {\n    if (this.defaultEventExecutorGroup == null) {\n        this.defaultEventExecutorGroup = new DefaultEventExecutorGroup(nettyClientConfig.getClientWorkerThreads(),\n                new NamedThreadFactory(getThreadPrefix(nettyClientConfig.getClientWorkerThreadPrefix()), nettyClientConfig.getClientWorkerThreads()));\n    }\n    this.bootstrap.group(this.eventLoopGroupWorker)\n            .channel(nettyClientConfig.getClientChannelClazz())\n            .option(ChannelOption.TCP_NODELAY, true)\n            .option(ChannelOption.SO_KEEPALIVE, true)\n            .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, nettyClientConfig.getConnectTimeoutMillis())\n            .option(ChannelOption.SO_SNDBUF, nettyClientConfig.getClientSocketSndBufSize())\n            .option(ChannelOption.SO_RCVBUF, nettyClientConfig.getClientSocketRcvBufSize());\n    if (nettyClientConfig.enableNative()) {\n        if (PlatformDependent.isOsx()) {\n            if (LOGGER.isInfoEnabled()) {\n                LOGGER.info("client run on macOS");\n            }\n        } else {\n            bootstrap.option(EpollChannelOption.EPOLL_MODE, EpollMode.EDGE_TRIGGERED)\n                    .option(EpollChannelOption.TCP_QUICKACK, true);\n        }\n    }\n    bootstrap.handler(new ChannelInitializer<SocketChannel>() {\n        @Override\n        public void initChannel(SocketChannel ch) {\n            ch.pipeline().addLast(new IdleStateHandler(nettyClientConfig.getChannelMaxReadIdleSeconds(),\n                            nettyClientConfig.getChannelMaxWriteIdleSeconds(),\n                            nettyClientConfig.getChannelMaxAllIdleSeconds()))\n                    .addLast(new ProtocolDecoderV1())\n                    .addLast(new ProtocolEncoderV1());\n            if (channelHandlers != null) {\n                addChannelPipelineLast(ch, channelHandlers);\n            }\n        }\n    });\n    if (initialized.compareAndSet(false, true) && LOGGER.isInfoEnabled()) {\n        LOGGER.info("NettyClientBootstrap has started");\n    }\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Since the protocol version for the client can be determined based on different versions of Seata, V1 version encoders and decoders are directly added here. The ",(0,s.jsx)(n.code,{children:"channelHandlers"})," are actually the ",(0,s.jsx)(n.code,{children:"ClientHandler"}),", which is also a composite handler in Netty."]}),"\n",(0,s.jsx)(n.h4,{id:"initialization-of-rm",children:"Initialization of RM"}),"\n",(0,s.jsx)(n.p,{children:"The initialization logic for RM is largely similar to that of TM and will not be elaborated on further here."}),"\n",(0,s.jsx)(n.h2,{id:"how-messages-are-sent-and-handled",children:"How Messages Are Sent and Handled"}),"\n",(0,s.jsx)(n.p,{children:"After understanding the general startup processes of the Seata Server and Client, we can delve deeper into how Seata sends and handles messages."}),"\n",(0,s.jsxs)(n.p,{children:["We mentioned earlier that the core logic for sending requests and processing messages lies within ",(0,s.jsx)(n.code,{children:"AbstractNettyRemoting"}),". Let's take a closer look at this class."]}),"\n",(0,s.jsx)(n.h3,{id:"synchronous-and-asynchronous",children:"Synchronous and Asynchronous"}),"\n",(0,s.jsx)(n.p,{children:"First, let's briefly discuss what synchronous and asynchronous mean."}),"\n",(0,s.jsx)(n.p,{children:"Synchronous (Synchronous) and Asynchronous (Asynchronous), in essence, describe different behavior patterns when a program handles multiple events or tasks."}),"\n",(0,s.jsx)(n.p,{children:"Synchronous means one process must wait for another to complete before it can proceed. In other words, in synchronous operations, the caller will block waiting for a response after issuing a request until it receives a response result or times out before continuing with subsequent code execution."}),"\n",(0,s.jsx)(n.p,{children:"In contrast, asynchronous allows the caller to continue executing without waiting for a response after making a request, but when the request is completed, it notifies the caller of the response in some way (such as through callback functions or Future). The asynchronous model can improve concurrency and efficiency."}),"\n",(0,s.jsx)(n.p,{children:"From another perspective, synchronous calls require the calling thread to obtain the result, whereas asynchronous calls either have an asynchronous thread place the result somewhere (Future) or execute pre-prepared call success/failure callback methods (callback function)."}),"\n",(0,s.jsx)(n.p,{children:"Below is a simple example demonstrating three invocation styles: synchronous, asynchronous with Future, and asynchronous with Callback."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'import lombok.Data;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.TimeUnit;\n\npublic class AsyncTest {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(AsyncTest.class);\n\n    public static void main(String[] args) throws InterruptedException, ExecutionException {\n        Result syncResponse = testSync();\n        LOGGER.info("Synchronous response result: {}", syncResponse.getString());\n        CompletableFuture<Result> result = testAsyncFuture();\n        testAsyncCallback();\n        LOGGER.info("Main thread continues executing~~");\n        TimeUnit.SECONDS.sleep(1); // Ensure all results are processed\n        LOGGER.info("Main thread retrieves result from async Future: {}", result.get().getString());\n    }\n\n    public static void testAsyncCallback() {\n        new AsyncTask().execute(new AsyncCallback() {\n            @Override\n            public void onComplete(Result result) {\n                try {\n                    TimeUnit.MILLISECONDS.sleep(50); // Simulate asynchronous delay\n                } catch (InterruptedException e) {\n                }\n                LOGGER.info("Async Callback gets result: {}", result.getString());\n            }\n        });\n    }\n\n    public static CompletableFuture<Result> testAsyncFuture() {\n        return CompletableFuture.supplyAsync(() -> {\n            try {\n                TimeUnit.MILLISECONDS.sleep(50); // Simulate asynchronous delay\n            } catch (InterruptedException e) {\n            }\n            Result asyncResponse = getResult();\n            LOGGER.info("Async Future gets result: {}", asyncResponse.getString());\n            return asyncResponse;\n        });\n    }\n\n    public static Result testSync() {\n        return getResult();\n    }\n\n    @Data\n    static class Result {\n        private String string;\n    }\n\n    interface AsyncCallback {\n        void onComplete(Result result);\n    }\n\n    static class AsyncTask {\n        void execute(AsyncCallback callback) {\n            new Thread(() -> {\n                Result asyncRes = getResult();\n                callback.onComplete(asyncRes);\n            }).start();\n        }\n    }\n\n    private static Result getResult() {\n        Result result = new Result();\n        result.setString("result");\n        return result;\n    }\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"Output:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"22:26:38.788 [main] INFO  org.hein.netty.AsyncTest - Synchronous response result: result\n22:26:38.849 [main] INFO  org.hein.netty.AsyncTest - Main thread continues executing~~\n22:26:38.911 [Thread-0] INFO  org.hein.netty.AsyncTest - Async Callback gets result: result\n22:26:38.911 [ForkJoinPool.commonPool-worker-1] INFO  org.hein.netty.AsyncTest - Async Future gets result: result\n22:26:39.857 [main] INFO  org.hein.netty.AsyncTest - Main thread retrieves result from async Future: result\n"})}),"\n",(0,s.jsx)(n.p,{children:"From the output, we can observe at least three points:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"One is that asynchronous Future and asynchronous Callback do not block the main thread from continuing its execution."}),"\n",(0,s.jsx)(n.li,{children:"Two, the handling of results during asynchronous calls is not done by the main thread."}),"\n",(0,s.jsx)(n.li,{children:"Finally, the difference between Future and Callback lies in that Future has the asynchronous thread store the result in a specific location (CompletableFuture#result), but retrieving the result still requires the main thread (or another thread) to call the get method. With Callback, it's essentially setting up the predefined way to handle the result, which is executed by the asynchronous thread."}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Of course, ",(0,s.jsx)(n.code,{children:"CompletableFuture"})," can also be used for callbacks, for example, by calling the ",(0,s.jsx)(n.code,{children:"whenComplete"})," method."]}),"\n",(0,s.jsx)(n.h3,{id:"asynchronous-invocation",children:"Asynchronous Invocation"}),"\n",(0,s.jsx)(n.p,{children:"Netty, as a high-performance asynchronous IO framework, is designed to be asynchronous at its core. Therefore, implementing asynchronous calls based on Netty is relatively straightforward."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'protected void sendAsync(Channel channel, RpcMessage rpcMessage) {\n    channelWritableCheck(channel, rpcMessage.getBody());\n    if (LOGGER.isDebugEnabled()) {\n        LOGGER.debug("write message: {}, channel: {}, active? {}, writable? {}, isopen? {}", rpcMessage.getBody(), channel, channel.isActive(), channel.isWritable(), channel.isOpen());\n    }\n    doBeforeRpcHooks(ChannelUtil.getAddressFromChannel(channel), rpcMessage);\n    channel.writeAndFlush(rpcMessage).addListener((ChannelFutureListener) future -> {\n        if (!future.isSuccess()) {\n            destroyChannel(future.channel());\n        }\n    });\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["An asynchronous call can be achieved by simply invoking the ",(0,s.jsx)(n.code,{children:"writeAndFlush"})," method of the channel."]}),"\n",(0,s.jsxs)(n.p,{children:["It's important to note that the ",(0,s.jsx)(n.code,{children:"writeAndFlush"})," method will operate synchronously when called from an EventLoop thread."]}),"\n",(0,s.jsx)(n.h3,{id:"synchronous-invocation",children:"Synchronous Invocation"}),"\n",(0,s.jsx)(n.p,{children:"Implementing asynchronous calls in Netty is simple, but converting them into synchronous calls requires more effort since it involves transforming an asynchronous call into a synchronous one."}),"\n",(0,s.jsx)(n.p,{children:"Essentially, converting asynchronous to synchronous means that after the calling thread initiates a call, it should block until it receives a response, and then it continues execution."}),"\n",(0,s.jsxs)(n.p,{children:["The core of Seata's handling for this conversion lies within the ",(0,s.jsx)(n.code,{children:"MessageFuture"})," class, as follows:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'package org.apache.seata.core.protocol;\n\nimport org.apache.seata.common.exception.ShouldNeverHappenException;\n\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\npublic class MessageFuture {\n\n    private RpcMessage requestMessage;\n    private long timeout;\n    private final long start = System.currentTimeMillis();\n\n    private final transient CompletableFuture<Object> origin = new CompletableFuture<>();\n\n    public boolean isTimeout() {\n        return System.currentTimeMillis() - start > timeout;\n    }\n\n    public Object get(long timeout, TimeUnit unit) throws TimeoutException, InterruptedException {\n        Object result;\n        try {\n            result = origin.get(timeout, unit);\n            if (result instanceof TimeoutException) {\n                throw (TimeoutException) result;\n            }\n        } catch (ExecutionException e) {\n            throw new ShouldNeverHappenException("Should not get results in a multi-threaded environment", e);\n        } catch (TimeoutException e) {\n            throw new TimeoutException(String.format("%s, cost: %d ms", e.getMessage(), System.currentTimeMillis() - start));\n        }\n        if (result instanceof RuntimeException) {\n            throw (RuntimeException) result;\n        } else if (result instanceof Throwable) {\n            throw new RuntimeException((Throwable) result);\n        }\n        return result;\n    }\n\n    public void setResultMessage(Object obj) {\n        origin.complete(obj);\n    }\n\n    public RpcMessage getRequestMessage() { return requestMessage; }\n\n    public void setRequestMessage(RpcMessage requestMessage) { this.requestMessage = requestMessage;}\n\n    public long getTimeout() { return timeout; }\n\n    public void setTimeout(long timeout) { this.timeout = timeout;}\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"With this class, the process of a synchronous call works as follows, using a client request and server response as an example:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["First, the client constructs the request into a ",(0,s.jsx)(n.code,{children:"MessageFuture"}),", then stores the request ID along with this ",(0,s.jsx)(n.code,{children:"MessageFuture"})," object in a hash table."]}),"\n",(0,s.jsxs)(n.li,{children:["The client then calls ",(0,s.jsx)(n.code,{children:"channel.writeAndFlush"})," to initiate an asynchronous call. Yes, it's still asynchronous at this point."]}),"\n",(0,s.jsxs)(n.li,{children:["The key to converting asynchronous to synchronous lies in the fact that the thread needs to call the ",(0,s.jsx)(n.code,{children:"get"})," method on the ",(0,s.jsx)(n.code,{children:"MessageFuture"})," object, which blocks the thread, effectively calling the ",(0,s.jsx)(n.code,{children:"get"})," method on ",(0,s.jsx)(n.code,{children:"CompletableFuture"})," to enter a blocking state."]}),"\n",(0,s.jsx)(n.li,{children:"When the server finishes processing and sends a request from its perspective, the client sees this as a response."}),"\n",(0,s.jsxs)(n.li,{children:["When the client receives the response, the EventLoop thread sets the response result in the ",(0,s.jsx)(n.code,{children:"MessageFuture"}),". Since the request and response IDs are the same, the corresponding ",(0,s.jsx)(n.code,{children:"MessageFuture"})," object can be retrieved from the aforementioned hash table."]}),"\n",(0,s.jsx)(n.li,{children:"Once the response result is set, the previously blocked thread can resume execution, thereby achieving a synchronous effect."}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Thus, Seata's solution essentially uses ",(0,s.jsx)(n.code,{children:"CompletableFuture"})," objects as containers for storing results."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'protected Object sendSync(Channel channel, RpcMessage rpcMessage, long timeoutMillis) throws TimeoutException {\n    if (timeoutMillis <= 0) {\n        throw new FrameworkException("timeout should more than 0ms");\n    }\n    if (channel == null) {\n        LOGGER.warn("sendSync nothing, caused by null channel.");\n        return null;\n    }\n    MessageFuture messageFuture = new MessageFuture();\n    messageFuture.setRequestMessage(rpcMessage);\n    messageFuture.setTimeout(timeoutMillis);\n    futures.put(rpcMessage.getId(), messageFuture); // The request and response IDs are the same\n    // Check if the Channel is writable (Channels have write buffers, and if the buffer reaches a threshold water level, it becomes unwritable)\n    channelWritableCheck(channel, rpcMessage.getBody());\n    // Get the destination IP address\n    String remoteAddr = ChannelUtil.getAddressFromChannel(channel);\n    // Execute pre-send hooks\n    doBeforeRpcHooks(remoteAddr, rpcMessage);\n    // Send the result and set up a callback, non-blocking\n    channel.writeAndFlush(rpcMessage).addListener((ChannelFutureListener) future -> {\n        // If sending fails, remove the future and close the Channel\n        if (!future.isSuccess()) {\n            MessageFuture mf = futures.remove(rpcMessage.getId());\n            if (mf != null) {\n                mf.setResultMessage(future.cause());\n            }\n            destroyChannel(future.channel());\n        }\n    });\n    try {\n        // Since Netty sends asynchronously, we need to wait for the result here, converting async to sync\n        Object result = messageFuture.get(timeoutMillis, TimeUnit.MILLISECONDS);\n        // Execute post-send hooks\n        doAfterRpcHooks(remoteAddr, rpcMessage, result);\n        return result;\n    } catch (Exception exx) {\n        LOGGER.error("wait response error:{},ip:{},request:{}", exx.getMessage(), channel.remoteAddress(), rpcMessage.getBody());\n        // Timeout exception\n        if (exx instanceof TimeoutException) {\n            throw (TimeoutException) exx;\n        } else {\n            throw new RuntimeException(exx);\n        }\n    }\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"message-handling",children:"Message Handling"}),"\n",(0,s.jsx)(n.p,{children:"When it comes to message handling in Netty, one should think of inbound and outbound handlers first."}),"\n",(0,s.jsxs)(n.p,{children:["In the Seata Server side, besides common encoding and decoding handlers, there is also the ",(0,s.jsx)(n.code,{children:"ServerHandler"}),". Here's an example:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'@ChannelHandler.Sharable\nclass ServerHandler extends ChannelDuplexHandler {\n\n    @Override\n    public void channelRead(final ChannelHandlerContext ctx, Object msg) throws Exception {\n        // Preceded by a decoder handler, so the message here is RpcMessage\n        if (msg instanceof RpcMessage) {\n            processMessage(ctx, (RpcMessage) msg);\n        } else {\n            LOGGER.error("rpcMessage type error");\n        }\n    }\n\n    // ...\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"channelRead"})," method has significant business meaning, as all messages sent to the Server will come to this method after being decoded."]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"processMessage"})," method within this context refers to the business processing method found in ",(0,s.jsx)(n.code,{children:"AbstractNettyRemoting"}),", as follows:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'protected void processMessage(ChannelHandlerContext ctx, RpcMessage rpcMessage) throws Exception {\n    if (LOGGER.isDebugEnabled()) {\n        LOGGER.debug("{} msgId: {}, body: {}", this, rpcMessage.getId(), rpcMessage.getBody());\n    }\n    Object body = rpcMessage.getBody();\n    if (body instanceof MessageTypeAware) {\n        MessageTypeAware messageTypeAware = (MessageTypeAware) body;\n        // During Server startup, a lot of processors are registered with processorTable\n        final Pair<RemotingProcessor, ExecutorService> pair = this.processorTable.get((int) messageTypeAware.getTypeCode());\n        if (pair != null) {\n            // Execute with the corresponding thread pool\n            if (pair.getSecond() != null) {\n                try {\n                    pair.getSecond().execute(() -> {\n                        try {\n                            // Find the corresponding processor to execute\n                            pair.getFirst().process(ctx, rpcMessage);\n                        } catch (Throwable th) {\n                            LOGGER.error(FrameworkErrorCode.NetDispatch.getErrCode(), th.getMessage(), th);\n                        } finally {\n                            MDC.clear();\n                        }\n                    });\n                } catch (RejectedExecutionException e) {\n                    // Thread pool is full, execute rejection policy\n                    LOGGER.error(FrameworkErrorCode.ThreadPoolFull.getErrCode(), "thread pool is full, current max pool size is " + messageExecutor.getActiveCount());\n                    if (allowDumpStack) {\n                        // Export thread stack information\n                        String name = ManagementFactory.getRuntimeMXBean().getName();\n                        String pid = name.split("@")[0];\n                        long idx = System.currentTimeMillis();\n                        try {\n                            String jstackFile = idx + ".log";\n                            LOGGER.info("jstack command will dump to {}", jstackFile);\n                            Runtime.getRuntime().exec(String.format("jstack %s > %s", pid, jstackFile));\n                        } catch (IOException exx) {\n                            LOGGER.error(exx.getMessage());\n                        }\n                        allowDumpStack = false;\n                    }\n                }\n            } else {\n                try {\n                    // If no thread pool is configured for the processor, it is executed by the current thread, which is basically the EventLoop thread\n                    pair.getFirst().process(ctx, rpcMessage);\n                } catch (Throwable th) {\n                    LOGGER.error(FrameworkErrorCode.NetDispatch.getErrCode(), th.getMessage(), th);\n                }\n            }\n        } else {\n            LOGGER.error("This message type [{}] has no processor.", messageTypeAware.getTypeCode());\n        }\n    } else {\n        LOGGER.error("This rpcMessage body[{}] is not MessageTypeAware type.", body);\n    }\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"The logic of this method is quite straightforward."}),"\n",(0,s.jsxs)(n.p,{children:["During the startup process of Seata Server, a multitude of processors are registered into the ",(0,s.jsx)(n.code,{children:"processorTable"}),", so here we can obtain the corresponding processor and thread pool based on the message type code."]}),"\n",(0,s.jsx)(n.p,{children:"If there is a thread pool, the processor's method is executed within that thread pool; otherwise, it is handed over to the EventLoop thread for execution."}),"\n",(0,s.jsx)(n.p,{children:"Of course, the same approach applies to the Client."}),"\n",(0,s.jsx)(n.h3,{id:"batch-sending",children:"Batch Sending"}),"\n",(0,s.jsx)(n.p,{children:"In network programming, there are times when batch sending is also required. Let's see how Seata implements this, focusing on the client sending to the server."}),"\n",(0,s.jsxs)(n.p,{children:["Recall that during the Client startup process, we mentioned a thread pool ",(0,s.jsx)(n.code,{children:"mergeSendExecutorService"}),". If batch sending is allowed, then upon Client startup, a ",(0,s.jsx)(n.code,{children:"MergedSendRunnable"})," task is submitted. First, let's look at what this task does:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'private class MergedSendRunnable implements Runnable {\n\n    @Override\n    public void run() {\n        // Infinite loop\n        while (true) {\n            synchronized (mergeLock) {\n                try {\n                    // Ensure the thread idles for no more than 1ms\n                    mergeLock.wait(MAX_MERGE_SEND_MILLS); // 1\n                } catch (InterruptedException ignore) {\n                    // ignore\n                }\n            }\n            // Flag indicating sending in progress\n            isSending = true;\n            // basketMap: key is address, value is the queue of messages (blocking queue) to be sent to that address\n            basketMap.forEach((address, basket) -> {\n                if (basket.isEmpty()) {\n                    return;\n                }\n                MergedWarpMessage mergeMessage = new MergedWarpMessage();\n                while (!basket.isEmpty()) {\n                    // Merge all RpcMessages from the same blocking queue\n                    RpcMessage msg = basket.poll();\n                    mergeMessage.msgs.add((AbstractMessage) msg.getBody());\n                    mergeMessage.msgIds.add(msg.getId());\n                }\n                if (mergeMessage.msgIds.size() > 1) {\n                    printMergeMessageLog(mergeMessage);\n                }\n                Channel sendChannel = null;\n                try {\n                    // Batch message sending is a synchronous request but doesn\'t require a return value.\n                    // Because messageFuture is created before putting the message into basketMap.\n                    // The return value will be set in ClientOnResponseProcessor.\n                    sendChannel = clientChannelManager.acquireChannel(address);\n                    // Internally wraps mergeMessage as a regular RpcMessage and sends it\n                    AbstractNettyRemotingClient.this.sendAsyncRequest(sendChannel, mergeMessage);\n                } catch (FrameworkException e) {\n                    if (e.getErrorCode() == FrameworkErrorCode.ChannelIsNotWritable && sendChannel != null) {\n                        destroyChannel(address, sendChannel);\n                    }\n                    // Fast fail\n                    for (Integer msgId : mergeMessage.msgIds) {\n                        MessageFuture messageFuture = futures.remove(msgId);\n                        if (messageFuture != null) {\n                            messageFuture.setResultMessage(new RuntimeException(String.format("%s is unreachable", address), e));\n                        }\n                    }\n                    LOGGER.error("client merge call failed: {}", e.getMessage(), e);\n                }\n            });\n            isSending = false;\n        }\n    }\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"The related batch sending code follows:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'public Object sendSyncRequest(Object msg) throws TimeoutException {\n    String serverAddress = loadBalance(getTransactionServiceGroup(), msg);\n    long timeoutMillis = this.getRpcRequestTimeout();\n    RpcMessage rpcMessage = buildRequestMessage(msg, ProtocolConstants.MSGTYPE_RESQUEST_SYNC);\n    // Send batch message\n    // Put message into basketMap, @see MergedSendRunnable\n    if (this.isEnableClientBatchSendRequest()) {\n        // If client-side batch message sending is enabled\n        // Sending batch messages is a sync request, which needs to create messageFuture and put it in futures.\n        MessageFuture messageFuture = new MessageFuture();\n        messageFuture.setRequestMessage(rpcMessage);\n        messageFuture.setTimeout(timeoutMillis);\n        futures.put(rpcMessage.getId(), messageFuture);\n\n        // Put message into basketMap\n        // Get the sending queue corresponding to serverAddress\n        BlockingQueue<RpcMessage> basket = CollectionUtils.computeIfAbsent(basketMap, serverAddress,\n                key -> new LinkedBlockingQueue<>());\n        // Add the message to the queue, waiting for mergeSendExecutorService to perform the actual sending\n        if (!basket.offer(rpcMessage)) {\n            LOGGER.error("put message into basketMap offer failed, serverAddress: {}, rpcMessage: {}", serverAddress, rpcMessage);\n            return null;\n        }\n        if (!isSending) {\n            // Ensure that once there is data in the queue, the thread is awakened to continue batch sending\n            synchronized (mergeLock) {\n                mergeLock.notifyAll();\n            }\n        }\n        try {\n            // Thread blocks waiting for response\n            return messageFuture.get(timeoutMillis, TimeUnit.MILLISECONDS);\n        } catch (Exception exx) {\n            LOGGER.error("wait response error: {}, ip: {}, request: {}", exx.getMessage(), serverAddress, rpcMessage.getBody());\n            if (exx instanceof TimeoutException) {\n                throw (TimeoutException) exx;\n            } else {\n                throw new RuntimeException(exx);\n            }\n        }\n    } else {\n        // Normal sending, acquire channel and call the parent class\'s synchronous method\n        Channel channel = clientChannelManager.acquireChannel(serverAddress);\n        return super.sendSync(channel, rpcMessage, timeoutMillis);\n    }\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"As can be seen, object lock synchronization-wait mechanisms are used here, resulting in the following effects:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["Messages are sent by traversing the ",(0,s.jsx)(n.code,{children:"basketMap"})," every 1ms at most."]}),"\n",(0,s.jsxs)(n.li,{children:["During the blocking period of threads inside ",(0,s.jsx)(n.code,{children:"mergeSendExecutorService"})," (mainLock.wait), if a message that needs to be sent arrives, the thread on ",(0,s.jsx)(n.code,{children:"mainLock"})," is awakened to continue sending."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["How does the Server handle this? It mainly looks at the ",(0,s.jsx)(n.code,{children:"TypeCode"})," of the ",(0,s.jsx)(n.code,{children:"MergedWarpMessage"}),", which is actually ",(0,s.jsx)(n.code,{children:"TYPE_SEATA_MERGE"}),". During Server startup, the processor registered for this Code is actually ",(0,s.jsx)(n.code,{children:"ServerOnRequestProcessor"}),"."]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"This shows you how to find out how a certain message is processed; teaching you how to fish is better than giving you fish!"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["On the ",(0,s.jsx)(n.code,{children:"ServerOnRequestProcessor"})," side, there are actually two ways to handle ",(0,s.jsx)(n.code,{children:"MergedWarpMessage"})," messages:"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["After processing all individual requests within ",(0,s.jsx)(n.code,{children:"MergedWarpMessage"}),", send a unified ",(0,s.jsx)(n.code,{children:"MergeResultMessage"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["Handle the sending task with the ",(0,s.jsx)(n.code,{children:"batchResponseExecutorService"})," thread pool, ensuring two points: one is to respond immediately when there is a message result, even if the thread is waiting, it will notify it, and secondly, it responds at least once every 1ms because the thread executing within ",(0,s.jsx)(n.code,{children:"batchResponseExecutorService"})," waits for no more than 1ms."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Note that these two methods respond with different message types; the first responds with ",(0,s.jsx)(n.code,{children:"MergeResultMessage"}),", and the second with ",(0,s.jsx)(n.code,{children:"BatchResultMessage"}),", each handled differently on the Client side."]}),"\n",(0,s.jsxs)(n.p,{children:["The core processing method within ",(0,s.jsx)(n.code,{children:"ServerOnRequestProcessor"})," is as follows:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'private void onRequestMessage(ChannelHandlerContext ctx, RpcMessage rpcMessage) {\n    Object message = rpcMessage.getBody();\n    RpcContext rpcContext = ChannelManager.getContextFromIdentified(ctx.channel());\n    // the batch send request message\n    if (message instanceof MergedWarpMessage) {\n        final List<AbstractMessage> msgs = ((MergedWarpMessage) message).msgs;\n        final List<Integer> msgIds = ((MergedWarpMessage) message).msgIds;\n        // Allow TC server to batch return results && client version >= 1.5.0\n        if (NettyServerConfig.isEnableTcServerBatchSendResponse() && StringUtils.isNotBlank(rpcContext.getVersion())\n                && Version.isAboveOrEqualVersion150(rpcContext.getVersion())) {\n            // Handled by `batchResponseExecutorService` individually without waiting for all batch requests to complete\n            for (int i = 0; i < msgs.size(); i++) {\n                if (PARALLEL_REQUEST_HANDLE) {\n                    int finalI = i;\n                    CompletableFuture.runAsync(\n                            () -> handleRequestsByMergedWarpMessageBy150(msgs.get(finalI), msgIds.get(finalI), rpcMessage, ctx, rpcContext));\n                } else {\n                    handleRequestsByMergedWarpMessageBy150(msgs.get(i), msgIds.get(i), rpcMessage, ctx, rpcContext);\n                }\n            }\n        } else {\n            // Responses are sent only after each request has been processed\n            List<AbstractResultMessage> results = new ArrayList<>();\n            List<CompletableFuture<AbstractResultMessage>> futures = new ArrayList<>();\n            for (int i = 0; i < msgs.size(); i++) {\n                if (PARALLEL_REQUEST_HANDLE) {\n                    int finalI = i;\n                    futures.add(CompletableFuture.supplyAsync(() -> handleRequestsByMergedWarpMessage(msgs.get(finalI), rpcContext)));\n                } else {\n                    results.add(i, handleRequestsByMergedWarpMessage(msgs.get(i), rpcContext));\n                }\n            }\n            if (CollectionUtils.isNotEmpty(futures)) {\n                try {\n                    for (CompletableFuture<AbstractResultMessage> future : futures) {\n                        results.add(future.get()); // Blocking wait for processing result\n                    }\n                } catch (InterruptedException | ExecutionException e) {\n                    LOGGER.error("handle request error: {}", e.getMessage(), e);\n                }\n            }\n            MergeResultMessage resultMessage = new MergeResultMessage();\n            resultMessage.setMsgs(results.toArray(new AbstractResultMessage[0]));\n            remotingServer.sendAsyncResponse(rpcMessage, ctx.channel(), resultMessage);\n        }\n    } else {\n        // Handle individual message response\n    }\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["The difference between ",(0,s.jsx)(n.code,{children:"handleRequestsByMergedWarpMessage"})," and ",(0,s.jsx)(n.code,{children:"handleRequestsByMergedWarpMessageBy150"})," lies in the fact that the latter encapsulates the result into a ",(0,s.jsx)(n.code,{children:"QueueItem"})," and adds it to a blocking queue for actual sending by threads in ",(0,s.jsx)(n.code,{children:"batchResponseExecutorService"}),", while the former simply returns the processing result."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'private AbstractResultMessage handleRequestsByMergedWarpMessage(AbstractMessage subMessage, RpcContext rpcContext) {\n    AbstractResultMessage resultMessage = transactionMessageHandler.onRequest(subMessage, rpcContext);\n    return resultMessage;\n}\n\nprivate void handleRequestsByMergedWarpMessageBy150(AbstractMessage msg, int msgId, RpcMessage rpcMessage,\n                                                    ChannelHandlerContext ctx, RpcContext rpcContext) {\n    AbstractResultMessage resultMessage = transactionMessageHandler.onRequest(msg, rpcContext);\n    // Get the sending queue corresponding to the channel\n    BlockingQueue<QueueItem> msgQueue = CollectionUtils.computeIfAbsent(basketMap, ctx.channel(), key -> new LinkedBlockingQueue<>());\n    // Add the result to the queue, waiting for `batchResponseExecutorService` thread pool to perform the actual sending\n    if (!msgQueue.offer(new QueueItem(resultMessage, msgId, rpcMessage))) {\n        LOGGER.error("put message into basketMap offer failed, channel: {}, rpcMessage: {}, resultMessage: {}", ctx.channel(), rpcMessage, resultMessage);\n    }\n    if (!isResponding) {\n        // Ensure that once there is data in the queue, the thread is awakened to perform batch sending\n        synchronized (batchResponseLock) {\n            batchResponseLock.notifyAll();\n        }\n    }\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Now, let's look at how the ",(0,s.jsx)(n.code,{children:"batchResponseExecutorService"})," thread pool handles batch sending tasks:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'private class BatchResponseRunnable implements Runnable {\n    @Override\n    public void run() {\n        while (true) {\n            synchronized (batchResponseLock) {\n                try {\n                    // Idle for no more than 1ms\n                    batchResponseLock.wait(MAX_BATCH_RESPONSE_MILLS);\n                } catch (InterruptedException e) {\n                    LOGGER.error("BatchResponseRunnable Interrupted error", e);\n                }\n            }\n            isResponding = true;\n            // Traverse `basketMap` for processing\n            basketMap.forEach((channel, msgQueue) -> {\n                if (msgQueue.isEmpty()) {\n                    return;\n                }\n                // Group responses according to [serialization,compressor,rpcMessageId,headMap] dimensions.\n                // Encapsulate queue messages into `BatchResultMessage` but not send all at once.\n                // Send asynchronously per group based on [serialization,compressor,rpcMessageId,headMap].\n                Map<ClientRequestRpcInfo, BatchResultMessage> batchResultMessageMap = new HashMap<>();\n                while (!msgQueue.isEmpty()) {\n                    QueueItem item = msgQueue.poll();\n                    BatchResultMessage batchResultMessage = CollectionUtils.computeIfAbsent(batchResultMessageMap,\n                            new ClientRequestRpcInfo(item.getRpcMessage()),\n                            key -> new BatchResultMessage());\n                    batchResultMessage.getResultMessages().add(item.getResultMessage());\n                    batchResultMessage.getMsgIds().add(item.getMsgId());\n                }\n                batchResultMessageMap.forEach((clientRequestRpcInfo, batchResultMessage) ->\n                        remotingServer.sendAsyncResponse(buildRpcMessage(clientRequestRpcInfo), channel, batchResultMessage));\n            });\n            isResponding = false;\n        }\n    }\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Finally, let's see how the Client side processes Server's batch response messages. According to the processor registered by the Client, the processor handling batch messages is ",(0,s.jsx)(n.code,{children:"ClientOnResponseProcessor"}),", as follows:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'public void process(ChannelHandlerContext ctx, RpcMessage rpcMessage) throws Exception {\n    // Process `MergeResultMessage`\n    if (rpcMessage.getBody() instanceof MergeResultMessage) {\n        MergeResultMessage results = (MergeResultMessage) rpcMessage.getBody();\n        MergedWarpMessage mergeMessage = (MergedWarpMessage) mergeMsgMap.remove(rpcMessage.getId());\n        for (int i = 0; i < mergeMessage.msgs.size(); i++) {\n            int msgId = mergeMessage.msgIds.get(i);\n            MessageFuture future = futures.remove(msgId);\n            if (future == null) {\n                LOGGER.error("msg: {} is not found in futures, result message: {}", msgId, results.getMsgs()[i]);\n            } else {\n                future.setResultMessage(results.getMsgs()[i]);\n            }\n        }\n    } else if (rpcMessage.getBody() instanceof BatchResultMessage) {\n        // Process `BatchResultMessage`\n        try {\n            BatchResultMessage batchResultMessage = (BatchResultMessage) rpcMessage.getBody();\n            for (int i = 0; i < batchResultMessage.getMsgIds().size(); i++) {\n                int msgId = batchResultMessage.getMsgIds().get(i);\n                MessageFuture future = futures.remove(msgId);\n                if (future == null) {\n                    LOGGER.error("msg: {} is not found in futures, result message: {}", msgId, batchResultMessage.getResultMessages().get(i));\n                } else {\n                    future.setResultMessage(batchResultMessage.getResultMessages().get(i));\n                }\n            }\n        } finally {\n            // For compatibility with old versions, in batch sending of version 1.5.0,\n            // batch messages will also be placed in the local cache of `mergeMsgMap`,\n            // but version 1.5.0 no longer needs to obtain batch messages from `mergeMsgMap`.\n            mergeMsgMap.clear();\n        }\n    } else {\n        // Process non-batch sending messages\n        MessageFuture messageFuture = futures.remove(rpcMessage.getId());\n        if (messageFuture != null) {\n            messageFuture.setResultMessage(rpcMessage.getBody());\n        } else {\n            if (rpcMessage.getBody() instanceof AbstractResultMessage) {\n                if (transactionMessageHandler != null) {\n                    transactionMessageHandler.onResponse((AbstractResultMessage) rpcMessage.getBody(), null);\n                }\n            }\n        }\n    }\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Of course, the logic here is quite simple: it involves putting the results into the corresponding ",(0,s.jsx)(n.code,{children:"MessageFuture"}),", so the initially blocked thread that sent the request can obtain the result, thereby completing one cycle of batch sending and response handling."]}),"\n",(0,s.jsx)(n.p,{children:"Let's do some extra thinking: Why does Seata have two methods for batch sending, and which is better?"}),"\n",(0,s.jsxs)(n.p,{children:["For the ",(0,s.jsx)(n.code,{children:"MergeResultMessage"})," approach, it must wait until all messages have been processed before sending them out, so its response speed is limited by the longest-processing message, even if other messages could be sent out much sooner."]}),"\n",(0,s.jsxs)(n.p,{children:["However, the ",(0,s.jsx)(n.code,{children:"BatchResultMessage"})," approach differs in that it can achieve sending as soon as a message is processed, without waiting for other messages, thanks to parallel processing with ",(0,s.jsx)(n.code,{children:"CompletableFuture"}),". This method definitely responds faster."]}),"\n",(0,s.jsx)(n.p,{children:"The latter approach was introduced in Seata version 1.5 onwards, which can be seen as a better way to handle batch sending."}),"\n",(0,s.jsx)(n.p,{children:"Lastly, sharing an interaction flow diagram for global transaction commit requests by the author of the Seata RPC refactoring would be beneficial."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"image-20241217222048505",src:t(49746).A+"",width:"1080",height:"519"})}),"\n",(0,s.jsx)(n.h2,{id:"how-seata-manages-channel",children:"How Seata Manages Channel"}),"\n",(0,s.jsx)(n.p,{children:"Throughout the network communication process involving TC, TM, and RM, Channel is a critical communication component. To understand how Seata manages Channels, the easiest approach is to examine where the Server and Client obtain the Channel when sending messages."}),"\n",(0,s.jsxs)(n.p,{children:["In the ",(0,s.jsx)(n.code,{children:"sendSyncRequest"})," method of the ",(0,s.jsx)(n.code,{children:"AbstractNettyRemotingClient"})," class, we can see the following code:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"public Object sendSyncRequest(Object msg) throws TimeoutException {\n    // ...\n    // The Client acquires a Channel through NettyClientChannelManager\n    Channel channel = clientChannelManager.acquireChannel(serverAddress);\n    return super.sendSync(channel, rpcMessage, timeoutMillis);\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["And in the ",(0,s.jsx)(n.code,{children:"sendSyncRequest"})," method of the ",(0,s.jsx)(n.code,{children:"AbstractNettyRemotingServer"})," class, we can see the following code:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'public Object sendSyncRequest(String resourceId, String clientId, Object msg, boolean tryOtherApp) throws TimeoutException {\n    // The Server obtains a Channel through ChannelManager\n    Channel channel = ChannelManager.getChannel(resourceId, clientId, tryOtherApp);\n    if (channel == null) {\n        throw new RuntimeException("rm client is not connected. dbkey:" + resourceId + ",clientId:" + clientId);\n    }\n    RpcMessage rpcMessage = buildRequestMessage(msg, ProtocolConstants.MSGTYPE_RESQUEST_SYNC);\n    return super.sendSync(channel, rpcMessage, NettyServerConfig.getRpcRequestTimeout());\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Therefore, on the Client side, it mainly acquires Channels through ",(0,s.jsx)(n.code,{children:"NettyClientChannelManager"}),", while the Server retrieves Channels from ",(0,s.jsx)(n.code,{children:"ChannelManager"})," based on ",(0,s.jsx)(n.code,{children:"resourceId"})," and ",(0,s.jsx)(n.code,{children:"clientId"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"So, below we will primarily investigate these two classes along with some related logic."}),"\n",(0,s.jsx)(n.h3,{id:"client-channel",children:"Client Channel"}),"\n",(0,s.jsxs)(n.p,{children:["Let's first look at how Channels are managed on the Client side; the core class here is ",(0,s.jsx)(n.code,{children:"NettyClientChannelManager"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"First, let's take a simple look at the attributes of this class,"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"// serverAddress -> lock\nprivate final ConcurrentMap<String, Object> channelLocks = new ConcurrentHashMap<>();\n// serverAddress -> NettyPoolKey\nprivate final ConcurrentMap<String, NettyPoolKey> poolKeyMap = new ConcurrentHashMap<>();\n// serverAddress -> Channel\nprivate final ConcurrentMap<String, Channel> channels = new ConcurrentHashMap<>();\n// Object pool, NettyPoolKey -> Channel\nprivate final GenericKeyedObjectPool<NettyPoolKey, Channel> nettyClientKeyPool;\n// Functional interface, encapsulates the logic for obtaining a NettyPoolKey via serverAddress\nprivate final Function<String, NettyPoolKey> poolKeyFunction;\n"})}),"\n",(0,s.jsx)(n.h4,{id:"core-classes-of-the-object-pool",children:"Core Classes of the Object Pool"}),"\n",(0,s.jsxs)(n.p,{children:["Seata uses ",(0,s.jsx)(n.code,{children:"GenericKeyedObjectPool"})," as the object pool managing Channels."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"GenericKeyedObjectPool"})," is an implementation from the Apache Commons Pool library, primarily used for managing a set of object pools, each distinguished by a unique Key. It can support pooling requirements for multiple types of objects."]}),"\n",(0,s.jsxs)(n.p,{children:["When using ",(0,s.jsx)(n.code,{children:"GenericKeyedObjectPool"}),", it's typically necessary to configure a ",(0,s.jsx)(n.code,{children:"KeyedPoolableObjectFactory"}),". This factory defines how to create, validate, activate, passivate, and destroy objects within the pool."]}),"\n",(0,s.jsxs)(n.p,{children:["When ",(0,s.jsx)(n.code,{children:"GenericKeyedObjectPool"})," needs to create an object, it calls the ",(0,s.jsx)(n.code,{children:"makeObject"})," method of the ",(0,s.jsx)(n.code,{children:"KeyedPoolableObjectFactory"})," factory, and when it needs to destroy an object, it calls the ",(0,s.jsx)(n.code,{children:"destroyObject"})," method to destroy it\u2026\u2026"]}),"\n",(0,s.jsx)(n.h4,{id:"how-to-pool-channel",children:"How to Pool Channel"}),"\n",(0,s.jsxs)(n.p,{children:["The object being pooled is the Channel, and the corresponding Key is ",(0,s.jsx)(n.code,{children:"NettyPoolKey"}),", as follows:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"public class NettyPoolKey {\n\n    private TransactionRole transactionRole;\n    private String address;\n    private AbstractMessage message;\n\n    // ...\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["In ",(0,s.jsx)(n.code,{children:"NettyPoolKey"}),", three pieces of information are maintained: the transaction role (TM, RM, Server), the target TC Server address, and the RPC message sent by the Client when connecting to the Server."]}),"\n",(0,s.jsxs)(n.p,{children:["How is this ",(0,s.jsx)(n.code,{children:"NettyPoolKey"})," created? In Seata, the client actually has two roles, TM and RM, and the creation logic for each will be different. Therefore, Seata abstracts a method in ",(0,s.jsx)(n.code,{children:"AbstractNettyRemotingClient"})," whose return value is a functional interface that encapsulates the logic for creating a ",(0,s.jsx)(n.code,{children:"NettyPoolKey"})," based on ",(0,s.jsx)(n.code,{children:"serverAddress"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"// org.apache.seata.core.rpc.netty.AbstractNettyRemotingClient#getPoolKeyFunction\nprotected abstract Function<String, NettyPoolKey> getPoolKeyFunction();\n"})}),"\n",(0,s.jsx)(n.p,{children:"For example, the implementation in TM is:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"protected Function<String, NettyPoolKey> getPoolKeyFunction() {\n    return severAddress -> {\n        RegisterTMRequest message = new RegisterTMRequest(applicationId, transactionServiceGroup, getExtraData());\n        return new NettyPoolKey(NettyPoolKey.TransactionRole.TM_ROLE, severAddress, message);\n    };\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"And the implementation in RM is:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'protected Function<String, NettyPoolKey> getPoolKeyFunction() {\n    return serverAddress -> {\n        String resourceIds = getMergedResourceKeys();\n        if (resourceIds != null && LOGGER.isInfoEnabled()) {\n            LOGGER.info("RM will register: {}", resourceIds);\n        }\n        RegisterRMRequest message = new RegisterRMRequest(applicationId, transactionServiceGroup);\n        message.setResourceIds(resourceIds);\n        return new NettyPoolKey(NettyPoolKey.TransactionRole.RM_ROLE, serverAddress, message);\n    };\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["From here, you can see that the message sent by TM after connecting to the Server is ",(0,s.jsx)(n.code,{children:"RegisterTMRequest"}),", while for RM it is ",(0,s.jsx)(n.code,{children:"RegisterRMRequest"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"When is this functional interface called? We'll look at that later."}),"\n",(0,s.jsxs)(n.p,{children:["We also mentioned earlier that an object pool comes with a corresponding object creation factory ",(0,s.jsx)(n.code,{children:"KeyedPoolableObjectFactory"}),". In Seata, ",(0,s.jsx)(n.code,{children:"NettyPoolableFactory"})," extends ",(0,s.jsx)(n.code,{children:"KeyedPoolableObjectFactory"})," to implement this."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'/**\n * Netty Channel creation factory, creates Channel through NettyPoolKey, methods in this class must be thread-safe\n */\npublic class NettyPoolableFactory implements KeyedPoolableObjectFactory<NettyPoolKey, Channel> {\n\n    // ...\n    \n    /**\n     * This method is called when a new instance is needed\n     */\n    @Override\n    public Channel makeObject(NettyPoolKey key) {\n        InetSocketAddress address = NetUtil.toInetSocketAddress(key.getAddress());\n        // Create Channel, essentially connect to Seata Server via bootstrap.connect and return Channel\n        Channel tmpChannel = clientBootstrap.getNewChannel(address);\n        long start = System.currentTimeMillis();\n        Object response;\n        Channel channelToServer = null;\n        if (key.getMessage() == null) {\n            throw new FrameworkException("register msg is null, role:" + key.getTransactionRole().name());\n        }\n        try {\n            // Send Message, for TM it\'s RegisterTMRequest, for RM it\'s RegisterRMRequest\n            response = rpcRemotingClient.sendSyncRequest(tmpChannel, key.getMessage());\n            // Determine if registration was successful based on response\n            if (!isRegisterSuccess(response, key.getTransactionRole())) {\n                rpcRemotingClient.onRegisterMsgFail(key.getAddress(), tmpChannel, response, key.getMessage());\n            } else {\n                // Registration successful\n                channelToServer = tmpChannel;\n                // Add serverAddress as key and Channel as value to NettyClientChannelManager.channels\n                // If RM, possibly need to register resources with Server\n                rpcRemotingClient.onRegisterMsgSuccess(key.getAddress(), tmpChannel, response, key.getMessage());\n            }\n        } catch (Exception exx) {\n            if (tmpChannel != null) {\n                tmpChannel.close();\n            }\n            throw new FrameworkException("register " + key.getTransactionRole().name() + " error, errMsg:" + exx.getMessage());\n        }\n        return channelToServer;\n    }\n\n    // ...\n\n    @Override\n    public void destroyObject(NettyPoolKey key, Channel channel) throws Exception {\n        if (channel != null) {\n            channel.disconnect();\n            channel.close();\n        }\n    }\n\n    /**\n     * This method is called to validate object validity (optional) when borrowing an object\n     */\n    @Override\n    public boolean validateObject(NettyPoolKey key, Channel obj) {\n        if (obj != null && obj.isActive()) {\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * This method is called to activate the object when borrowing an object\n     */\n    @Override\n    public void activateObject(NettyPoolKey key, Channel obj) throws Exception {}\n\n    /**\n     * This method is called to passivate the object when returning it\n     */\n    @Override\n    public void passivateObject(NettyPoolKey key, Channel obj) throws Exception {}\n}\n'})}),"\n",(0,s.jsx)(n.h4,{id:"acquiring-channel",children:"Acquiring Channel"}),"\n",(0,s.jsx)(n.p,{children:"Throughout the Seata client, there are three ways to acquire a Channel: initialization, scheduled reconnection, and acquiring Channel when sending messages."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'// Entry point one\nprivate void initConnection() {\n    boolean failFast =\n            ConfigurationFactory.getInstance().getBoolean(ConfigurationKeys.ENABLE_TM_CLIENT_CHANNEL_CHECK_FAIL_FAST, DefaultValues.DEFAULT_CLIENT_CHANNEL_CHECK_FAIL_FAST);\n    getClientChannelManager().initReconnect(transactionServiceGroup, failFast);\n}\n\n// Entry point two\npublic void init() {\n    // Default delay 60s, periodic reconnect every 10s\n    timerExecutor.scheduleAtFixedRate(() -> {\n        try {\n            clientChannelManager.reconnect(getTransactionServiceGroup());\n        } catch (Exception ex) {\n            LOGGER.warn("reconnect server failed. {}", ex.getMessage());\n        }\n    }, SCHEDULE_DELAY_MILLS, SCHEDULE_INTERVAL_MILLS, TimeUnit.MILLISECONDS);\n    // ...\n}\n\n// Entry point three\npublic Object sendSyncRequest(Object msg) throws TimeoutException {\n    // ...\n    // Client acquires Channel through NettyClientChannelManager\n    Channel channel = clientChannelManager.acquireChannel(serverAddress);\n    return super.sendSync(channel, rpcMessage, timeoutMillis);\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["However, these three entry points will eventually call the ",(0,s.jsx)(n.code,{children:"acquireChannel"})," method of ",(0,s.jsx)(n.code,{children:"clientChannelManager"})," to obtain a Channel."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'/**\n * Get Channel based on serverAddress, if Channel does not exist or connection is dead then need to establish a new connection\n */\nChannel acquireChannel(String serverAddress) {\n    // Get Channel from channels based on serverAddress\n    Channel channelToServer = channels.get(serverAddress);\n    if (channelToServer != null) {\n        channelToServer = getExistAliveChannel(channelToServer, serverAddress);\n        if (channelToServer != null) {\n            return channelToServer;\n        }\n    }\n    // If Channel does not exist in channels or this Channel is dead, then need to establish a connection for this address\n    Object lockObj = CollectionUtils.computeIfAbsent(channelLocks, serverAddress, key -> new Object());\n    synchronized (lockObj) {\n        // Establish connection\n        return doConnect(serverAddress);\n    }\n}\n\nprivate Channel doConnect(String serverAddress) {\n    // Try to get once more\n    Channel channelToServer = channels.get(serverAddress);\n    if (channelToServer != null && channelToServer.isActive()) {\n        return channelToServer;\n    }\n    Channel channelFromPool;\n    try {\n        // Call the functional interface here\n        NettyPoolKey currentPoolKey = poolKeyFunction.apply(serverAddress);\n        poolKeyMap.put(serverAddress, currentPoolKey);\n        // Borrow object from the object pool, if object creation is needed, it will call the factory\'s makeObject method,\n        // which internally connects to the Server and sends the message of currentPoolKey.message\n        channelFromPool = nettyClientKeyPool.borrowObject(currentPoolKey);\n        channels.put(serverAddress, channelFromPool);\n    } catch (Exception exx) {\n        LOGGER.error("{} register RM failed.", FrameworkErrorCode.RegisterRM.getErrCode(), exx);\n        throw new FrameworkException("can not register RM,err:" + exx.getMessage());\n    }\n    return channelFromPool;\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"server-channel",children:"Server Channel"}),"\n",(0,s.jsxs)(n.p,{children:["On the Server side, almost all core logic related to Channel management is within ",(0,s.jsx)(n.code,{children:"ChannelManager"}),". So how does the Server get its Channels? Remember that on the Client side, after initiating a connection to the Server, it also sends a registration request for TM and RM."]}),"\n",(0,s.jsxs)(n.p,{children:["Let's first take a look at how the Server handles these ",(0,s.jsx)(n.code,{children:"registerRequest"}),"s."]}),"\n",(0,s.jsx)(n.h4,{id:"handling-client-registration",children:"Handling Client Registration"}),"\n",(0,s.jsxs)(n.p,{children:["The related handlers are ",(0,s.jsx)(n.code,{children:"RegRmProcessor"})," and ",(0,s.jsx)(n.code,{children:"RegTmProcessor"}),". In these two processors, the core logic involves calling the ",(0,s.jsx)(n.code,{children:"ChannelManager"}),"'s ",(0,s.jsx)(n.code,{children:"registerTMChannel"})," and ",(0,s.jsx)(n.code,{children:"registerRMChannel"})," methods."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"public static void registerTMChannel(RegisterTMRequest request, Channel channel) throws IncompatibleVersionException {\n    // Build RpcContext, which maintains the context of client connection information\n    RpcContext rpcContext = buildChannelHolder(NettyPoolKey.TransactionRole.TM_ROLE, request.getVersion(),\n            request.getApplicationId(),\n            request.getTransactionServiceGroup(),\n            null, channel);\n    // Put Channel as key and rpcContext as value into IDENTIFIED_CHANNELS\n    rpcContext.holdInIdentifiedChannels(IDENTIFIED_CHANNELS);\n    // applicationId:clientIp\n    String clientIdentified = rpcContext.getApplicationId() + Constants.CLIENT_ID_SPLIT_CHAR + ChannelUtil.getClientIpFromChannel(channel);\n    // Store Channel information in TM_CHANNELS\n    ConcurrentMap<Integer, RpcContext> clientIdentifiedMap = CollectionUtils.computeIfAbsent(TM_CHANNELS, clientIdentified, key -> new ConcurrentHashMap<>());\n    rpcContext.holdInClientChannels(clientIdentifiedMap);\n}\n\npublic static void registerRMChannel(RegisterRMRequest resourceManagerRequest, Channel channel) throws IncompatibleVersionException {\n    Set<String> dbkeySet = dbKeytoSet(resourceManagerRequest.getResourceIds());\n    RpcContext rpcContext;\n    if (!IDENTIFIED_CHANNELS.containsKey(channel)) {\n        // Build RpcContext and IDENTIFIED_CHANNELS\n        rpcContext = buildChannelHolder(NettyPoolKey.TransactionRole.RM_ROLE, resourceManagerRequest.getVersion(),\n                resourceManagerRequest.getApplicationId(), resourceManagerRequest.getTransactionServiceGroup(),\n                resourceManagerRequest.getResourceIds(), channel);\n        rpcContext.holdInIdentifiedChannels(IDENTIFIED_CHANNELS);\n    } else {\n        rpcContext = IDENTIFIED_CHANNELS.get(channel);\n        rpcContext.addResources(dbkeySet);\n    }\n    if (dbkeySet == null || dbkeySet.isEmpty()) {\n        return;\n    }\n    for (String resourceId : dbkeySet) {\n        String clientIp;\n        // Maintain RM_CHANNELS information\n        ConcurrentMap<Integer, RpcContext> portMap = CollectionUtils.computeIfAbsent(RM_CHANNELS, resourceId, key -> new ConcurrentHashMap<>())\n                .computeIfAbsent(resourceManagerRequest.getApplicationId(), key -> new ConcurrentHashMap<>())\n                .computeIfAbsent(clientIp = ChannelUtil.getClientIpFromChannel(channel), key -> new ConcurrentHashMap<>());\n        rpcContext.holdInResourceManagerChannels(resourceId, portMap);\n        updateChannelsResource(resourceId, clientIp, resourceManagerRequest.getApplicationId());\n    }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["These two methods have relatively simple logic. They construct an ",(0,s.jsx)(n.code,{children:"RpcContext"})," based on the registration request and Channel information, maintaining relevant Map collections within the Server such as ",(0,s.jsx)(n.code,{children:"IDENTIFIED_CHANNELS"}),", ",(0,s.jsx)(n.code,{children:"RM_CHANNELS"}),", and ",(0,s.jsx)(n.code,{children:"TM_CHANNELS"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"However, to be honest, these collections are nested quite deeply, and it is uncertain whether they can be optimized."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"/**\n * Channel -> RpcContext\n */\nprivate static final ConcurrentMap<Channel, RpcContext> IDENTIFIED_CHANNELS = new ConcurrentHashMap<>();\n\n/**\n * resourceId -> applicationId -> ip -> port -> RpcContext\n */\n//                               resourceId          applicationId               ip\nprivate static final ConcurrentMap<String, ConcurrentMap<String, ConcurrentMap<String,\n        //             port    RpcContext\n        ConcurrentMap<Integer, RpcContext>>>> RM_CHANNELS = new ConcurrentHashMap<>();\n\n/**\n * applicationId:clientIp -> port -> RpcContext\n */\nprivate static final ConcurrentMap<String, ConcurrentMap<Integer, RpcContext>> TM_CHANNELS = new ConcurrentHashMap<>();\n"})}),"\n",(0,s.jsx)(n.h4,{id:"acquiring-channel-1",children:"Acquiring Channel"}),"\n",(0,s.jsx)(n.p,{children:"On the Server side, the logic for acquiring a Channel is really long; those interested can take a look by themselves. Essentially, it involves obtaining an effective Channel from the map."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'public static Channel getChannel(String resourceId, String clientId, boolean tryOtherApp) {\n    Channel resultChannel = null;\n    // Parse ClientId, composed of three parts: applicationId + clientIp + clientPort\n    String[] clientIdInfo = parseClientId(clientId);\n    if (clientIdInfo == null || clientIdInfo.length != 3) {\n        throw new FrameworkException("Invalid Client ID: " + clientId);\n    }\n    if (StringUtils.isBlank(resourceId)) {\n        if (LOGGER.isInfoEnabled()) {\n            LOGGER.info("No channel is available, resourceId is null or empty");\n        }\n        return null;\n    }\n    // applicationId\n    String targetApplicationId = clientIdInfo[0];\n    // clientIp\n    String targetIP = clientIdInfo[1];\n    // clientPort\n    int targetPort = Integer.parseInt(clientIdInfo[2]);\n    // Below is continuously extracting the inner ConcurrentHashMaps\n    ConcurrentMap<String, ConcurrentMap<String, ConcurrentMap<Integer, RpcContext>>> applicationIdMap = RM_CHANNELS.get(resourceId);\n    if (targetApplicationId == null || applicationIdMap == null || applicationIdMap.isEmpty()) {\n        if (LOGGER.isInfoEnabled()) {\n            LOGGER.info("No channel is available for resource[{}]", resourceId);\n        }\n        return null;\n    }\n    ConcurrentMap<String, ConcurrentMap<Integer, RpcContext>> ipMap = applicationIdMap.get(targetApplicationId);\n    if (ipMap != null && !ipMap.isEmpty()) {\n        // Firstly, try to find the original channel through which the branch was registered.\n        // Port -> RpcContext\n        ConcurrentMap<Integer, RpcContext> portMapOnTargetIP = ipMap.get(targetIP);\n        /**\n         * Get Channel on targetIp\n         */\n        if (portMapOnTargetIP != null && !portMapOnTargetIP.isEmpty()) {\n            RpcContext exactRpcContext = portMapOnTargetIP.get(targetPort);\n            if (exactRpcContext != null) {\n                Channel channel = exactRpcContext.getChannel();\n                if (channel.isActive()) {\n                    // If Channel is valid, skip all following ifs and return this Channel\n                    resultChannel = channel;\n                    if (LOGGER.isDebugEnabled()) {\n                        LOGGER.debug("Just got exactly the one {} for {}", channel, clientId);\n                    }\n                } else {\n                    if (portMapOnTargetIP.remove(targetPort, exactRpcContext)) {\n                        if (LOGGER.isInfoEnabled()) {\n                            LOGGER.info("Removed inactive {}", channel);\n                        }\n                    }\n                }\n            }\n            // The original channel was broken, try another one.\n            if (resultChannel == null) {\n                // Try other ports on the current node\n                for (ConcurrentMap.Entry<Integer, RpcContext> portMapOnTargetIPEntry : portMapOnTargetIP.entrySet()) {\n                    Channel channel = portMapOnTargetIPEntry.getValue().getChannel();\n                    if (channel.isActive()) {\n                        resultChannel = channel;\n                        if (LOGGER.isInfoEnabled()) {\n                            LOGGER.info(\n                                    "Choose {} on the same IP[{}] as alternative of {}", channel, targetIP, clientId);\n                        }\n                        break;\n                    } else {\n                        if (portMapOnTargetIP.remove(portMapOnTargetIPEntry.getKey(),\n                                portMapOnTargetIPEntry.getValue())) {\n                            if (LOGGER.isInfoEnabled()) {\n                                LOGGER.info("Removed inactive {}", channel);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        /**\n         * Get Channel on targetApplicationId\n         */\n        // No channel on the app node, try another one.\n        if (resultChannel == null) {\n            for (ConcurrentMap.Entry<String, ConcurrentMap<Integer, RpcContext>> ipMapEntry : ipMap.entrySet()) {\n                if (ipMapEntry.getKey().equals(targetIP)) {\n                    continue;\n                }\n                ConcurrentMap<Integer, RpcContext> portMapOnOtherIP = ipMapEntry.getValue();\n                if (portMapOnOtherIP == null || portMapOnOtherIP.isEmpty()) {\n                    continue;\n                }\n                for (ConcurrentMap.Entry<Integer, RpcContext> portMapOnOtherIPEntry : portMapOnOtherIP.entrySet()) {\n                    Channel channel = portMapOnOtherIPEntry.getValue().getChannel();\n                    if (channel.isActive()) {\n                        resultChannel = channel;\n                        if (LOGGER.isInfoEnabled()) {\n                            LOGGER.info("Choose {} on the same application[{}] as alternative of {}", channel, targetApplicationId, clientId);\n                        }\n                        break;\n                    } else {\n                        if (portMapOnOtherIP.remove(portMapOnOtherIPEntry.getKey(), portMapOnOtherIPEntry.getValue())) {\n                            if (LOGGER.isInfoEnabled()) {\n                                LOGGER.info("Removed inactive {}", channel);\n                            }\n                        }\n                    }\n                }\n                if (resultChannel != null) {\n                    break;\n                }\n            }\n        }\n    }\n    if (resultChannel == null && tryOtherApp) {\n        // Try other applicationId\n        resultChannel = tryOtherApp(applicationIdMap, targetApplicationId);\n        if (resultChannel == null) {\n            if (LOGGER.isInfoEnabled()) {\n                LOGGER.info("No channel is available for resource[{}] as alternative of {}", resourceId, clientId);\n            }\n        } else {\n            if (LOGGER.isInfoEnabled()) {\n                LOGGER.info("Choose {} on the same resource[{}] as alternative of {}", resultChannel, resourceId, clientId);\n            }\n        }\n    }\n    return resultChannel;\n}\n\nprivate static Channel tryOtherApp(ConcurrentMap<String, ConcurrentMap<String, ConcurrentMap<Integer, RpcContext>>> applicationIdMap, String myApplicationId) {\n    Channel chosenChannel = null;\n    for (ConcurrentMap.Entry<String, ConcurrentMap<String, ConcurrentMap<Integer, RpcContext>>> applicationIdMapEntry : applicationIdMap.entrySet()) {\n        if (!StringUtils.isNullOrEmpty(myApplicationId) && applicationIdMapEntry.getKey().equals(myApplicationId)) {\n            continue;\n        }\n        ConcurrentMap<String, ConcurrentMap<Integer, RpcContext>> targetIPMap = applicationIdMapEntry.getValue();\n        if (targetIPMap == null || targetIPMap.isEmpty()) {\n            continue;\n        }\n        for (ConcurrentMap.Entry<String, ConcurrentMap<Integer, RpcContext>> targetIPMapEntry : targetIPMap.entrySet()) {\n            ConcurrentMap<Integer, RpcContext> portMap = targetIPMapEntry.getValue();\n            if (portMap == null || portMap.isEmpty()) {\n                continue;\n            }\n            for (ConcurrentMap.Entry<Integer, RpcContext> portMapEntry : portMap.entrySet()) {\n                Channel channel = portMapEntry.getValue().getChannel();\n                if (channel.isActive()) {\n                    chosenChannel = channel;\n                    break;\n                } else {\n                    if (portMap.remove(portMapEntry.getKey(), portMapEntry.getValue())) {\n                        if (LOGGER.isInfoEnabled()) {\n                            LOGGER.info("Removed inactive {}", channel);\n                        }\n                    }\n                }\n            }\n            if (chosenChannel != null) {\n                break;\n            }\n        }\n        if (chosenChannel != null) {\n            break;\n        }\n    }\n    return chosenChannel;\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"summary-in-a-sequence-diagram",children:"Summary in a Sequence Diagram"}),"\n",(0,s.jsx)(n.p,{children:"Finally, let's summarize the Channel management process with a sequence diagram."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"image-20241217222155609",src:t(47306).A+"",width:"1538",height:"1169"})}),"\n",(0,s.jsx)(n.h2,{id:"how-seata-designs-its-protocol",children:"How Seata Designs Its Protocol"}),"\n",(0,s.jsx)(n.p,{children:"For any network program, communication protocols are indispensable, and Seata is no exception. Here we will look at how the V1 version of the Seata protocol is implemented."}),"\n",(0,s.jsxs)(n.p,{children:["The main related classes are ",(0,s.jsx)(n.code,{children:"ProtocolEncoderV1"})," and ",(0,s.jsx)(n.code,{children:"ProtocolDecoderV1"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["Of course, as we know from before, the processor added when the Seata Server starts is actually ",(0,s.jsx)(n.code,{children:"MultiProtocolDecoder"}),". In this class's decode method, it works as follows:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'protected Object decode(ChannelHandlerContext ctx, ByteBuf in) throws Exception {\n    ByteBuf frame;\n    Object decoded;\n    byte version;\n    try {\n        if (isV0(in)) {\n            decoded = in;\n            version = ProtocolConstants.VERSION_0;\n        } else {\n            decoded = super.decode(ctx, in);\n            version = decideVersion(decoded);\n        }\n        if (decoded instanceof ByteBuf) {\n            frame = (ByteBuf) decoded;\n            // Identify multi-version protocols through MultiProtocolDecoder\n            // Select the corresponding codec based on version\n            ProtocolDecoder decoder = protocolDecoderMap.get(version);\n            ProtocolEncoder encoder = protocolEncoderMap.get(version);\n            try {\n                if (decoder == null || encoder == null) {\n                    throw new UnsupportedOperationException("Unsupported version: " + version);\n                }\n                return decoder.decodeFrame(frame);\n            } finally {\n                if (version != ProtocolConstants.VERSION_0) {\n                    frame.release();\n                }\n                // Add the selected codec to the pipeline and remove MultiProtocolDecoder\n                ctx.pipeline().addLast((ChannelHandler) decoder);\n                ctx.pipeline().addLast((ChannelHandler) encoder);\n                if (channelHandlers != null) {\n                    ctx.pipeline().addLast(channelHandlers);\n                }\n                ctx.pipeline().remove(this);\n            }\n        }\n    } catch (Exception exx) {\n        LOGGER.error("Decode frame error, cause: {}", exx.getMessage());\n        throw new DecodeException(exx);\n    }\n    return decoded;\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Therefore, here the corresponding codec for the version is chosen, then added to the pipeline, which will remove the ",(0,s.jsx)(n.code,{children:"MultiProtocolDecoder"}),"."]}),"\n",(0,s.jsx)(n.h3,{id:"v1-version-protocol",children:"V1 Version Protocol"}),"\n",(0,s.jsx)(n.p,{children:"Seata's protocol design is quite comprehensive and general, also being a mainstream solution to address issues like message fragmentation and partial messages, namely message length + message content."}),"\n",(0,s.jsx)(n.p,{children:"The format of the protocol is as follows:"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"image-20241217222155609",src:t(83103).A+"",width:"1456",height:"352"})}),"\n",(0,s.jsx)(n.p,{children:"As can be seen, it includes magic numbers, protocol version numbers, length fields, header lengths, message types, serialization algorithms, compression algorithms, request IDs, optional map extensions, and the message body."}),"\n",(0,s.jsx)(n.h3,{id:"how-encoding-and-decoding-are-performed",children:"How Encoding and Decoding Are Performed"}),"\n",(0,s.jsxs)(n.p,{children:["Seata decoders use Netty's built-in ",(0,s.jsx)(n.code,{children:"LengthFieldBasedFrameDecoder"}),"; those unfamiliar with it can take a look."]}),"\n",(0,s.jsx)(n.p,{children:"However, encoding and decoding are not difficult, so I'll simply provide the code without much explanation."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'package org.apache.seata.core.rpc.netty.v1;\n\nimport io.netty.buffer.ByteBuf;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.handler.codec.MessageToByteEncoder;\nimport org.apache.seata.core.rpc.netty.ProtocolEncoder;\nimport org.apache.seata.core.serializer.Serializer;\nimport org.apache.seata.core.compressor.Compressor;\nimport org.apache.seata.core.compressor.CompressorFactory;\nimport org.apache.seata.core.protocol.ProtocolConstants;\nimport org.apache.seata.core.protocol.RpcMessage;\nimport org.apache.seata.core.serializer.SerializerServiceLoader;\nimport org.apache.seata.core.serializer.SerializerType;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.Map;\n\n/**\n * <pre>\n * 0     1     2     3     4     5     6     7     8     9    10     11    12    13    14    15    16\n * +-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+\n * |   magic   |proto|     full length       |    head   | Msg |Seria|Compr|      RequestId        |\n * |   code    |versi|     (head+body)       |   length  |Type |lizer|ess  |                       |\n * +-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+\n * |                                   Head Map [Optional]                                         |\n * +-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+\n * |                                         body                                                  |\n * +-----------------------------------------------------------------------------------------------+\n * </pre>\n * <p>\n * <li>Full Length: include all data </li>\n * <li>Head Length: include head data from magic code to head map. </li>\n * <li>Body Length: Full Length - Head Length</li>\n * </p>\n */\npublic class ProtocolEncoderV1 extends MessageToByteEncoder implements ProtocolEncoder {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(ProtocolEncoderV1.class);\n\n    public void encode(RpcMessage message, ByteBuf out) {\n        try {\n            ProtocolRpcMessageV1 rpcMessage = new ProtocolRpcMessageV1();\n            rpcMessage.rpcMsgToProtocolMsg(message);\n            int fullLength = ProtocolConstants.V1_HEAD_LENGTH;\n            int headLength = ProtocolConstants.V1_HEAD_LENGTH;\n            byte messageType = rpcMessage.getMessageType();\n            out.writeBytes(ProtocolConstants.MAGIC_CODE_BYTES);\n            out.writeByte(ProtocolConstants.VERSION_1);\n            // full Length(4B) and head length(2B) will fix in the end.\n            out.writerIndex(out.writerIndex() + 6); // Here we skip the full length and head length positions and fill in the last\n            out.writeByte(messageType);\n            out.writeByte(rpcMessage.getCodec());\n            out.writeByte(rpcMessage.getCompressor());\n            out.writeInt(rpcMessage.getId());\n            // direct write head with zero-copy\n            Map<String, String> headMap = rpcMessage.getHeadMap();\n            if (headMap != null && !headMap.isEmpty()) {\n                int headMapBytesLength = HeadMapSerializer.getInstance().encode(headMap, out);\n                headLength += headMapBytesLength;\n                fullLength += headMapBytesLength;\n            }\n            byte[] bodyBytes = null;\n            // heartbeat don\'t have body\n            if (messageType != ProtocolConstants.MSGTYPE_HEARTBEAT_REQUEST && messageType != ProtocolConstants.MSGTYPE_HEARTBEAT_RESPONSE) {\n                Serializer serializer = SerializerServiceLoader.load(SerializerType.getByCode(rpcMessage.getCodec()), ProtocolConstants.VERSION_1);\n                bodyBytes = serializer.serialize(rpcMessage.getBody());\n                Compressor compressor = CompressorFactory.getCompressor(rpcMessage.getCompressor());\n                bodyBytes = compressor.compress(bodyBytes);\n                fullLength += bodyBytes.length;\n            }\n            if (bodyBytes != null) {\n                out.writeBytes(bodyBytes);\n            }\n            // fix fullLength and headLength\n            int writeIndex = out.writerIndex();\n            // skip magic code(2B) + version(1B)\n            out.writerIndex(writeIndex - fullLength + 3);\n            out.writeInt(fullLength);\n            out.writeShort(headLength);\n            out.writerIndex(writeIndex);\n        } catch (Throwable e) {\n            LOGGER.error("Encode request error!", e);\n            throw e;\n        }\n    }\n\n    @Override\n    protected void encode(ChannelHandlerContext ctx, Object msg, ByteBuf out) throws Exception {\n        try {\n            if (msg instanceof RpcMessage) {\n                this.encode((RpcMessage) msg, out);\n            } else {\n                throw new UnsupportedOperationException("Not support this class:" + msg.getClass());\n            }\n        } catch (Throwable e) {\n            LOGGER.error("Encode request error!", e);\n        }\n    }\n}\n'})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'package org.apache.seata.core.rpc.netty.v1;\n\nimport java.util.List;\nimport java.util.Map;\n\nimport io.netty.buffer.ByteBuf;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.handler.codec.LengthFieldBasedFrameDecoder;\nimport org.apache.seata.core.compressor.Compressor;\nimport org.apache.seata.core.compressor.CompressorFactory;\nimport org.apache.seata.core.exception.DecodeException;\nimport org.apache.seata.core.protocol.HeartbeatMessage;\nimport org.apache.seata.core.protocol.ProtocolConstants;\nimport org.apache.seata.core.protocol.RpcMessage;\nimport org.apache.seata.core.rpc.netty.ProtocolDecoder;\nimport org.apache.seata.core.serializer.Serializer;\nimport org.apache.seata.core.serializer.SerializerServiceLoader;\nimport org.apache.seata.core.serializer.SerializerType;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * <pre>\n * 0     1     2     3     4     5     6     7     8     9    10     11    12    13    14    15    16\n * +-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+\n * |   magic   |proto|     full length       |    head   | Msg |Seria|Compr|      RequestId        |\n * |   code    |versi|     (head+body)       |   length  |Type |lizer|ess  |                       |\n * +-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+\n * |                                   Head Map [Optional]                                         |\n * +-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+\n * |                                         body                                                  |\n * +-----------------------------------------------------------------------------------------------+\n * </pre>\n * <p>\n * <li>Full Length: include all data </li>\n * <li>Head Length: include head data from magic code to head map. </li>\n * <li>Body Length: Full Length - Head Length</li>\n * </p>\n */\npublic class ProtocolDecoderV1 extends LengthFieldBasedFrameDecoder implements ProtocolDecoder {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(ProtocolDecoderV1.class);\n\n    private final List<SerializerType> supportDeSerializerTypes;\n\n    public ProtocolDecoderV1() {\n        /**\n         *  int maxFrameLength,\n         *  int lengthFieldOffset,  Magic 2B, version 1B so the length is offset by 3B\n         *  int lengthFieldLength,  FullLength is int(4B). so values is 4\n         *  int lengthAdjustment,   FullLength include all data and read 7 bytes before, so the left length is (FullLength-7). so values is -7\n         *  int initialBytesToStrip we will check magic code and version self, so do not strip any bytes. so values is 0\n         */\n        super(ProtocolConstants.MAX_FRAME_LENGTH, 3, 4, -7, 0);\n        supportDeSerializerTypes = SerializerServiceLoader.getSupportedSerializers();\n        if (supportDeSerializerTypes.isEmpty()) {\n            throw new IllegalArgumentException("No serializer found");\n        }\n    }\n\n    @Override\n    public RpcMessage decodeFrame(ByteBuf frame) {\n        byte b0 = frame.readByte();\n        byte b1 = frame.readByte();\n        if (ProtocolConstants.MAGIC_CODE_BYTES[0] != b0 || ProtocolConstants.MAGIC_CODE_BYTES[1] != b1) {\n            throw new IllegalArgumentException("Unknown magic code: " + b0 + ", " + b1);\n        }\n        byte version = frame.readByte();\n        int fullLength = frame.readInt();\n        short headLength = frame.readShort();\n        byte messageType = frame.readByte();\n        byte codecType = frame.readByte();\n        byte compressorType = frame.readByte();\n        int requestId = frame.readInt();\n        ProtocolRpcMessageV1 rpcMessage = new ProtocolRpcMessageV1();\n        rpcMessage.setCodec(codecType);\n        rpcMessage.setId(requestId);\n        rpcMessage.setCompressor(compressorType);\n        rpcMessage.setMessageType(messageType);\n        // direct read head with zero-copy\n        int headMapLength = headLength - ProtocolConstants.V1_HEAD_LENGTH;\n        if (headMapLength > 0) {\n            Map<String, String> map = HeadMapSerializer.getInstance().decode(frame, headMapLength);\n            rpcMessage.getHeadMap().putAll(map);\n        }\n        // read body\n        if (messageType == ProtocolConstants.MSGTYPE_HEARTBEAT_REQUEST) {\n            rpcMessage.setBody(HeartbeatMessage.PING);\n        } else if (messageType == ProtocolConstants.MSGTYPE_HEARTBEAT_RESPONSE) {\n            rpcMessage.setBody(HeartbeatMessage.PONG);\n        } else {\n            int bodyLength = fullLength - headLength;\n            if (bodyLength > 0) {\n                byte[] bs = new byte[bodyLength];\n                frame.readBytes(bs);\n                Compressor compressor = CompressorFactory.getCompressor(compressorType);\n                bs = compressor.decompress(bs);\n                SerializerType protocolType = SerializerType.getByCode(rpcMessage.getCodec());\n                if (this.supportDeSerializerTypes.contains(protocolType)) {\n                    Serializer serializer = SerializerServiceLoader.load(protocolType, ProtocolConstants.VERSION_1);\n                    rpcMessage.setBody(serializer.deserialize(bs));\n                } else {\n                    throw new IllegalArgumentException("SerializerType not match");\n                }\n            }\n        }\n        return rpcMessage.protocolMsgToRpcMsg();\n    }\n\n    @Override\n    protected Object decode(ChannelHandlerContext ctx, ByteBuf in) throws Exception {\n        Object decoded;\n        try {\n            decoded = super.decode(ctx, in);\n            if (decoded instanceof ByteBuf) {\n                ByteBuf frame = (ByteBuf) decoded;\n                try {\n                    return decodeFrame(frame);\n                } finally {\n                    frame.release();\n                }\n            }\n        } catch (Exception exx) {\n            LOGGER.error("Decode frame error, cause: {}", exx.getMessage());\n            throw new DecodeException(exx);\n        }\n        return decoded;\n    }\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,s.jsx)(n.p,{children:"From the current perspective, the implementation of network communication in Seata is relatively easy to understand. However, this article's analysis is only superficial and does not delve into deeper, more critical aspects such as code robustness, exception handling, graceful shutdown, etc. Further analysis will be provided if there are new insights in the future."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"https://blog.hein-hp.click/article/5p94ivva/",children:"Original Article Link"})})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},98021:(e,n,t)=>{t.d(n,{A:()=>s});const s=t.p+"assets/images/class-level-bd045d7bbafdae4554e51cffd11eace6.png"},47306:(e,n,t)=>{t.d(n,{A:()=>s});const s=t.p+"assets/images/seata-channel-2a36363196c8c68f8f9c058bbec413dc.png"},83103:(e,n,t)=>{t.d(n,{A:()=>s});const s=t.p+"assets/images/seata-protocol-5dc6fcbb74383edf784c3faa54236e74.png"},49746:(e,n,t)=>{t.d(n,{A:()=>s});const s=t.p+"assets/images/seata-rpc-1edb5b9dd8fc46db8e8f153a5dda3699.png"},28453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>i});var s=t(96540);const r={},a=s.createContext(r);function o(e){const n=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),s.createElement(a.Provider,{value:n},e.children)}}}]);